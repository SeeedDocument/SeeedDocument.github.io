{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\uf0c1\n\n\nWelcome to Seeed Wiki. Here, you will find user manuals and tutorials for \nSeeedStudio\ns\n products. This new website is constantly updated with contents from old \nwiki site\n. \n\n\nThe product documents are organized as:\n\n\n\n\nPlatform\n\n\nArduino\n\n\nBeagleBone\n\n\nRaspberry Pi\n\n\nLinkIt\n\n\nmbed\n\n\nRePhone\n\n\nWio\n\n\n\n\n\n\nGrove\n\n\nSensor\n\n\nActuator\n\n\nDisplay\n\n\nCommunication\n\n\nOthers\n\n\n\n\n\n\nIoT\n\n\nTutorial\n\n\nMakerPro\n\n\nAbout", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Welcome to Seeed Wiki. Here, you will find user manuals and tutorials for  SeeedStudio s  products. This new website is constantly updated with contents from old  wiki site .   The product documents are organized as:   Platform  Arduino  BeagleBone  Raspberry Pi  LinkIt  mbed  RePhone  Wio    Grove  Sensor  Actuator  Display  Communication  Others    IoT  Tutorial  MakerPro  About", 
            "title": "Introduction"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/", 
            "text": "Our new 1.12 OLED displays are perfect when you need a small display with 16 grayscale. The visible portion of the OLED measures 1.12\u201d diagonal and contains 96x96 grayscale pixels. Because the display uses OLEDs, there is no backlight, and the contrast is very high.\n\n\nThis OLED uses the SSD1327 driver chip, which manages the display. You can talk to the driver chip using 4-wire I2C (clock, data, power, and GND pins).\n\n\n\n\nCommunicate Mode: I2C\n\n\nGrayscale Display: 16 Gray shades.\n\n\nSupports both Normal and Inverse Color Display.\n\n\nSupports Continuous Horizontal Scrolling.\n\n\nGrove compatible Interface\n\n\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nOperating Voltage\n\n\n3.3/5 V\n\n\n\n\n\n\nDot Matrix\n\n\n96x96\n\n\n\n\n\n\nDisplay Color\n\n\n16 Grayscale\n\n\n\n\n\n\nOLED Display\n\n\nLY120-96096\n\n\n\n\n\n\nDriver Chip\n\n\nSSD1327Z\n\n\n\n\n\n\nDot Size\n\n\n0.15(W)mm x 0.15(H)mm\n\n\n\n\n\n\nDot Pitch\n\n\n0.75(W)mm x 0.175(H)mm\n\n\n\n\n\n\nOperating Temperature\n\n\n-40~70 oC\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nMore details about Grove modules please refer to \nGrove System\n\n\n\n\nPlatform Support\n\uf0c1\n\n\n\n\n\n\n\n\nArduino\n\n\nWio\n\n\nBeagleBone\n\n\nRaspberry Pi\n\n\nLinkIt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\n\n\nNote\n\n\nThis chapter is based on Win10 and Arduino IDE 1.6.9\n\n\n\n\nThis is an easy-to-use module, what you need to do is connect the module to I2C port of a Base Shield. There\nre 4 pins, defined as below.\n\n\n\n\n\n\n\n\npin\n\n\nFunction\n\n\nNote\n\n\nCable color\n\n\n\n\n\n\n\n\n\n\npin1\n\n\nSCL\n\n\nI2C Clock\n\n\nYELLOW\n\n\n\n\n\n\npin2\n\n\nSDA\n\n\nI2C Data\n\n\nWHITE\n\n\n\n\n\n\npin3\n\n\nVCC\n\n\nPower, 5V/3.3V\n\n\nRED\n\n\n\n\n\n\npin4\n\n\nGND\n\n\nGround\n\n\nBLACK\n\n\n\n\n\n\n\n\nHere we will show you how this Grove - OLED Display works via a simple demo. First of all, you need to prepare the below stuffs:\n\n\n\n\n\n\n\n\nSeeeduino V4\n\n\nGrove - OLED Display 1.12``\n\n\nBase Shield\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\n\n\n\n\n\n\nConnection\n\uf0c1\n\n\nThanks to the benefit of Grove series modules, you don\nt need to solder or bread board, what you need to do is connect the modules to the right port of Base Shield. For this demo, we have only one Grove module.\n\n\n\n\nGrove - OLED Display 1.12``\n is an \nI2C\n module, Only 4 connections are required for I2C communication, include SDA, SCL, VCC and GND. We connect it to \nI2C\n port at this demo. \n\n\n\n\n\nDownload the Library\n\uf0c1\n\n\nWe provide an Arduino Library for this Grove - OLED Display 1.12``, click on the below button to download it.\n\n\n\n\nUnzip the file and put to libraries folder of your Arduino IDE.\nThere\nre many examples in this library, which is consist of\n\n\n\n\nSeeed_OLED_Bitmap_Inverse_Display\n\n\nSeeed_OLED_Draw_Bitmap\n\n\nSeeed_OLED_Hello_World\n\n\nSeeed_OLED_Inverse_Display\n\n\nSeeed_OLED_PrintNumbers\n\n\nSeeed_OLED_Scroll_Left\n\n\nSeeed_OLED_Scroll_Right\n\n\nSeeed_OLED_Z_Display_Driver_Test_Suite\n\n\n\n\nUpload sketch to Arduino\n\uf0c1\n\n\nHello World\n\uf0c1\n\n\nNow let\ns try upload \nSeeed_OLED_Hello_World\n to Seeeduino V4. Open your Arduino IDE, click on\n\n\nFile \n Example \n Seeed_OLED_Display_96x96-master \n Seeed_OLED_Hello_World\n\n\n\n\n\n\nWhen the sketch is open, select the right board and right COM Port, then click on Upload button which will take few seconds.\n\n\n\n\nIf the sketch is uploaded correctly, you should see the following:\n\n\n\nDrawing Bitmaps\n\uf0c1\n\n\nWe have \nSeeed_OLED_Draw_Bitmap\n sketch in the library showing how to display full bitmap images. Upload the sketch and you should see the following: \n\n\n\nWe provide \nLattice modulo and LCD Assistance software\n with detail instructions to editing and crop your image to no large than 96 pixels high and 96 pixels wide.\n\n\nAPIs of the library\n\uf0c1\n\n\nSeeed Gray OLED library provides complete software interfaces to exercise the capabilities of SSD1327 driver with a 96x96 gray OLED. Almost all useful features are implemented and all functions are in public scope. This makes Seeed Gray OLED Library extensible. Seeed Gray OLED library uses Arduino Wire library. Hence initialize wire library before initializing Seeed OLED library.\n\n\ninit()\n\uf0c1\n\n\nInitializes the Seeed OLED frame and sets the display to Normal mode.\n\n\nExample:\n\n\nSeeedGrayOled.init();  //initialze SEEED Gray OLED display\n\n\n\nclearDisplay()\n\uf0c1\n\n\nClears the whole screen. Should be used before starting a fresh start or after scroll deactivation.\nThis function also sets the cursor to top left corner.\n\n\nExample:\n\n\nSeeedGrayOled.clearDisplay();  //clear the screen and set start position to top left corner\n\n\n\nsetNormalDisplay()\n\uf0c1\n\n\nConfigures the display to normal mode(non-inverse) mode.\n\n\nExample:\n\n\nSeeedGrayOled.setNormalDisplay();//Set display to normal mode (i.e non-inverse mode)\n\n\n\nsetContrastLevel(unsigned char ContrastLevel)\n\uf0c1\n\n\nSet the contrast ratio of OLED display. ContrastLevel can be any number from 0 - 255.\nExample:\n\n\nSeeedGrayOled.setContrastLevel(127); //Set display contrast ratio to half level( i.e 256/2 1 ).\n\n\n\nsetInverseDisplay())\n\uf0c1\n\n\nConfigures the display to inverse mode.\nExample:\n\n\nSeeedGrayOled.setInverseDisplay();      //Set display to inverse mode\n\n\n\nsetHorizontalMode()\n\uf0c1\n\n\nConfigures the display to horizontal addressing mode.\nExample:\n\n\nSeeedGrayOled.setHorizontalMode();      //Set addressing mode to Horizontal Mode\n\n\n\nsetVerticalMode()\n\uf0c1\n\n\nConfigures the display to vertical addressing mode. Texts are drawn in vertical mode. Please set\nthe display to vertical mode before printing text.\nExample:\n\n\nSeeedGrayOled.setVerticalMode();      //Set addressing mode to Vertical Mode\n\n\n\nsetTextXY(X,Y)\n\uf0c1\n\n\nSet the text\ns position (cursor) to Xth Text Row, Yth Text Column.96x96 OLED is divided into 12\nrows and 12 Columns of text. This row and column should not be confused with OLED Row and\nColumn.\n\n\n\n\nX can be any number from 0 - 11.\n\n\nY can be any number from 0 - 11.\n\n\n\n\nExample:\n\n\nSeeedGrayOled.setTextXY(0,0);  //Set the cursor to 0th Text Row, 0th Text Column\n\n\n\nputChar(unsigned char c)\n\uf0c1\n\n\nPrint a character to OLED display starting from current address-pointer set by setTextXY(X,Y). This\nfunction is internally used by putString().\n\n\nExample:\n\n\nSeeedGrayOled.putChar('S'); //Print the character S\n\n\n\nputString(cont char *string)\n\uf0c1\n\n\nPrint string to OLED display starting from current address-pointer set by setTextXY(X,Y)\nExample:\n\n\nSeeedGrayOled.putString(\"Hello World!\"); //Print the String\n\n\n\nputNumber(long n)\n\uf0c1\n\n\nPrint numbers to OLED display starting from current address-pointer set by setTextXY(X,Y).\nNumber can be any char,int or long datatype. It also takes care of -ve sign.\n\n\nExample:\n\n\nSeeedGrayOled.putNumber(-56123); //Print number -56123\n\n\n\ndrawBitmap(unsigned char *bitmaparray, int bytes)\n\uf0c1\n\n\nDisplay a binary bitmap on the OLED matrix. The data is provided through a pointer to uni-dimensional array holding bitmap. The bitmap data is available in continuous rows of columns\nas like Horizontal Addressing mode. bytes is size of bitmap in bytes.\n\n\nExample:\n\n\nSeeedGrayOled.drawBitmap(SeeedLogo,96*96/8);   //  Draw binary Bitmap (96 pixels *96 pixels  / 8) bytes\n\n\n\nsetHorizontalScrollProperties\n\uf0c1\n\n\nSet the properties of horizontal scroll.\n\n\n\n\nDirection can be any of Scroll_Left and Scroll_Right.\n\n\nstartRow can be 0 - 127\n\n\nendRow can be 0 - 127. It should be greater than startRow\n\n\nstartColumn can be 0 - 63\n\n\nendColumn can be 0 - 63. It should be greater than startRow\n\n\nscrollSpeed can be any of defines:Scroll_2Frames, Scroll_3Frames, Scroll_4Frames, Scroll_5Frames, Scroll_25Frames,Scroll_64Frames, Scroll_128Frames,Scroll_256Frames.\n\n\n\n\nExample:\n\n\nSeeedGrayOled.setHorizontalScrollProperties(Scroll_Left,72,95,0,47,Scroll_5Frames);  //Set the properties of Horizontal Scroll\n\n\n\nactivateScroll()\n\uf0c1\n\n\nEnable scrolling. This should be used only after setting horizontal scroll properties.\nExample:\n\n\nSeeedGrayOled.activateScroll();   //Enable scrolling.\n\n\n\ndeactivateScroll()\n\uf0c1\n\n\nDisable scrolling. This should be used after activateScroll();\nExample:\n\n\nSeeedGrayOled.activateScroll();   //Disable scrolling.\n\n\n\nResources\n\uf0c1\n\n\n\n\nSeeed_OLED_Display_96X96_master Library Github Repository \n\n\nSeeed OLED Schematic and PCB files\n\n\nDatasheet for SSD1327 Driver\n\n\nDatasheet for LY120\n\n\nReference for Make a 96x96 Image", 
            "title": "Grove - OLED Display 1.12`` NEW"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#specifications", 
            "text": "Item  Value      Operating Voltage  3.3/5 V    Dot Matrix  96x96    Display Color  16 Grayscale    OLED Display  LY120-96096    Driver Chip  SSD1327Z    Dot Size  0.15(W)mm x 0.15(H)mm    Dot Pitch  0.75(W)mm x 0.175(H)mm    Operating Temperature  -40~70 oC      Tip  More details about Grove modules please refer to  Grove System", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#platform-support", 
            "text": "Arduino  Wio  BeagleBone  Raspberry Pi  LinkIt", 
            "title": "Platform Support"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#getting-started", 
            "text": "Note  This chapter is based on Win10 and Arduino IDE 1.6.9   This is an easy-to-use module, what you need to do is connect the module to I2C port of a Base Shield. There re 4 pins, defined as below.     pin  Function  Note  Cable color      pin1  SCL  I2C Clock  YELLOW    pin2  SDA  I2C Data  WHITE    pin3  VCC  Power, 5V/3.3V  RED    pin4  GND  Ground  BLACK     Here we will show you how this Grove - OLED Display works via a simple demo. First of all, you need to prepare the below stuffs:     Seeeduino V4  Grove - OLED Display 1.12``  Base Shield           Get ONE Now  Get ONE Now  Get ONE Now", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#connection", 
            "text": "Thanks to the benefit of Grove series modules, you don t need to solder or bread board, what you need to do is connect the modules to the right port of Base Shield. For this demo, we have only one Grove module.   Grove - OLED Display 1.12``  is an  I2C  module, Only 4 connections are required for I2C communication, include SDA, SCL, VCC and GND. We connect it to  I2C  port at this demo.", 
            "title": "Connection"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#download-the-library", 
            "text": "We provide an Arduino Library for this Grove - OLED Display 1.12``, click on the below button to download it.   Unzip the file and put to libraries folder of your Arduino IDE.\nThere re many examples in this library, which is consist of   Seeed_OLED_Bitmap_Inverse_Display  Seeed_OLED_Draw_Bitmap  Seeed_OLED_Hello_World  Seeed_OLED_Inverse_Display  Seeed_OLED_PrintNumbers  Seeed_OLED_Scroll_Left  Seeed_OLED_Scroll_Right  Seeed_OLED_Z_Display_Driver_Test_Suite", 
            "title": "Download the Library"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#upload-sketch-to-arduino", 
            "text": "", 
            "title": "Upload sketch to Arduino"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#hello-world", 
            "text": "Now let s try upload  Seeed_OLED_Hello_World  to Seeeduino V4. Open your Arduino IDE, click on  File   Example   Seeed_OLED_Display_96x96-master   Seeed_OLED_Hello_World    When the sketch is open, select the right board and right COM Port, then click on Upload button which will take few seconds.   If the sketch is uploaded correctly, you should see the following:", 
            "title": "Hello World"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#drawing-bitmaps", 
            "text": "We have  Seeed_OLED_Draw_Bitmap  sketch in the library showing how to display full bitmap images. Upload the sketch and you should see the following:   We provide  Lattice modulo and LCD Assistance software  with detail instructions to editing and crop your image to no large than 96 pixels high and 96 pixels wide.", 
            "title": "Drawing Bitmaps"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#apis-of-the-library", 
            "text": "Seeed Gray OLED library provides complete software interfaces to exercise the capabilities of SSD1327 driver with a 96x96 gray OLED. Almost all useful features are implemented and all functions are in public scope. This makes Seeed Gray OLED Library extensible. Seeed Gray OLED library uses Arduino Wire library. Hence initialize wire library before initializing Seeed OLED library.", 
            "title": "APIs of the library"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#init", 
            "text": "Initializes the Seeed OLED frame and sets the display to Normal mode.  Example:  SeeedGrayOled.init();  //initialze SEEED Gray OLED display", 
            "title": "init()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#cleardisplay", 
            "text": "Clears the whole screen. Should be used before starting a fresh start or after scroll deactivation.\nThis function also sets the cursor to top left corner.  Example:  SeeedGrayOled.clearDisplay();  //clear the screen and set start position to top left corner", 
            "title": "clearDisplay()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#setnormaldisplay", 
            "text": "Configures the display to normal mode(non-inverse) mode.  Example:  SeeedGrayOled.setNormalDisplay();//Set display to normal mode (i.e non-inverse mode)", 
            "title": "setNormalDisplay()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#setcontrastlevelunsigned-char-contrastlevel", 
            "text": "Set the contrast ratio of OLED display. ContrastLevel can be any number from 0 - 255.\nExample:  SeeedGrayOled.setContrastLevel(127); //Set display contrast ratio to half level( i.e 256/2 1 ).", 
            "title": "setContrastLevel(unsigned char ContrastLevel)"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#setinversedisplay", 
            "text": "Configures the display to inverse mode.\nExample:  SeeedGrayOled.setInverseDisplay();      //Set display to inverse mode", 
            "title": "setInverseDisplay())"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#sethorizontalmode", 
            "text": "Configures the display to horizontal addressing mode.\nExample:  SeeedGrayOled.setHorizontalMode();      //Set addressing mode to Horizontal Mode", 
            "title": "setHorizontalMode()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#setverticalmode", 
            "text": "Configures the display to vertical addressing mode. Texts are drawn in vertical mode. Please set\nthe display to vertical mode before printing text.\nExample:  SeeedGrayOled.setVerticalMode();      //Set addressing mode to Vertical Mode", 
            "title": "setVerticalMode()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#settextxyxy", 
            "text": "Set the text s position (cursor) to Xth Text Row, Yth Text Column.96x96 OLED is divided into 12\nrows and 12 Columns of text. This row and column should not be confused with OLED Row and\nColumn.   X can be any number from 0 - 11.  Y can be any number from 0 - 11.   Example:  SeeedGrayOled.setTextXY(0,0);  //Set the cursor to 0th Text Row, 0th Text Column", 
            "title": "setTextXY(X,Y)"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#putcharunsigned-char-c", 
            "text": "Print a character to OLED display starting from current address-pointer set by setTextXY(X,Y). This\nfunction is internally used by putString().  Example:  SeeedGrayOled.putChar('S'); //Print the character S", 
            "title": "putChar(unsigned char c)"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#putstringcont-char-string", 
            "text": "Print string to OLED display starting from current address-pointer set by setTextXY(X,Y)\nExample:  SeeedGrayOled.putString(\"Hello World!\"); //Print the String", 
            "title": "putString(cont char *string)"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#putnumberlong-n", 
            "text": "Print numbers to OLED display starting from current address-pointer set by setTextXY(X,Y).\nNumber can be any char,int or long datatype. It also takes care of -ve sign.  Example:  SeeedGrayOled.putNumber(-56123); //Print number -56123", 
            "title": "putNumber(long n)"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#drawbitmapunsigned-char-bitmaparray-int-bytes", 
            "text": "Display a binary bitmap on the OLED matrix. The data is provided through a pointer to uni-dimensional array holding bitmap. The bitmap data is available in continuous rows of columns\nas like Horizontal Addressing mode. bytes is size of bitmap in bytes.  Example:  SeeedGrayOled.drawBitmap(SeeedLogo,96*96/8);   //  Draw binary Bitmap (96 pixels *96 pixels  / 8) bytes", 
            "title": "drawBitmap(unsigned char *bitmaparray, int bytes)"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#sethorizontalscrollproperties", 
            "text": "Set the properties of horizontal scroll.   Direction can be any of Scroll_Left and Scroll_Right.  startRow can be 0 - 127  endRow can be 0 - 127. It should be greater than startRow  startColumn can be 0 - 63  endColumn can be 0 - 63. It should be greater than startRow  scrollSpeed can be any of defines:Scroll_2Frames, Scroll_3Frames, Scroll_4Frames, Scroll_5Frames, Scroll_25Frames,Scroll_64Frames, Scroll_128Frames,Scroll_256Frames.   Example:  SeeedGrayOled.setHorizontalScrollProperties(Scroll_Left,72,95,0,47,Scroll_5Frames);  //Set the properties of Horizontal Scroll", 
            "title": "setHorizontalScrollProperties"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#activatescroll", 
            "text": "Enable scrolling. This should be used only after setting horizontal scroll properties.\nExample:  SeeedGrayOled.activateScroll();   //Enable scrolling.", 
            "title": "activateScroll()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#deactivatescroll", 
            "text": "Disable scrolling. This should be used after activateScroll();\nExample:  SeeedGrayOled.activateScroll();   //Disable scrolling.", 
            "title": "deactivateScroll()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch_new/#resources", 
            "text": "Seeed_OLED_Display_96X96_master Library Github Repository   Seeed OLED Schematic and PCB files  Datasheet for SSD1327 Driver  Datasheet for LY120  Reference for Make a 96x96 Image", 
            "title": "Resources"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/", 
            "text": "BASIC INFORMATION\n\uf0c1\n\n\nthis module name is \nWifi Shield V2.0\n, that enables your Arduino/Seeeduino board with the cool wifi connection capability. Equipped with the RN171 module, which is a complete standalone TCP/IP wireless \nnetwork module. We choose it all because it is prefect for wireless application such as assets monitoring, sensors, and portable battery operated devices. We are looking forward to the products you could \nbuild with our \nWifi Shield V2.0\n leverage its incredible low power consumption, and awesome configurable transmit power that you could adjust the signal power strong or weak based on your user cases.\n\n\nWHAT\nS NEW\n\uf0c1\n\n\nSeeedstudio always cares about your hacking experience, saving your energy on wiring and unnecessary accessories so that you could focus on core applications really matters. Our hardware team shapes the \n\nWifi Shield V2.0\n with Standard Shield and on-board antenna, so that you could \nplug and play\n with our amazing \nWifi Shield V2.0\n. Our on-board antenna allows the shield to cover a wider range and \ntransmit stronger signals. Our \nWifi Shield V2.0\n supports TCP, UDP, FTP, and HTTP communication protocols to meet the needs of most wireless and Internet of Things (IoT) network projects e.g. smart home \nnetworks, robots control, personal weather stations. \n\n\n\n\nHARDWARE OVERVIEW\n\uf0c1\n\n\n\n\n\n\nTip\n\n\nThe operating voltage of the RN-171 module is \n3.3V\nDC typically, so a voltage regulator and logic level translator are designed on the WiFi shield. The LD1117 regulator on the shield converts to 3.3VDC, which supplies the RN171 module. However, due to the auto judgement schematic of power supply, the RN-171 can be powered via both 3V3 pin and 5V pin. But the supply power would be 5v if providing both 3.3v and 5v to the board. If using with an Arduino/Seeeduino board simply stack the WiFi shield on the board.\n\n\n\n\nWHY CHOOSE US\n\uf0c1\n\n\nSeeedstudio is one of the largest open source hardware distributors, with high quality, cost effective, varies of open source products and great customer services. And most important we care about every \ncustomer. We are willing to learn from you and improve your every hacking experience by making perfect products of our time.\n\n\nwhat makes this product different from others\n\uf0c1\n\n\nAmong all of the Arduino Shields in the market, \nWifi Shield V2.0\n is one of a kind. It\ns the combination of conciseness and multi-functionality that we could have so many function just in one Shield with\nall of the flexibilities. It\ns such a good deal to enable your Arduino applications with this cost effective solution, so that you could easily scale out your products with a more competitive price point.\n\n\nHOW TO USE\n\uf0c1\n\n\nAs we just said, it\ns very easy to get start with the \nWifi Shield V2.0\n. We have provided a helpful library to assist you to interact with the Wifi Shield, with examples to let you walk through the main \nfunctions of the Shield.\n\n\nBASIC SETUP STEPS\n\uf0c1\n\n\nFirst thing first, we need to understand the basics of the Shield. How to find whether it\ns working fine or not? How to configure the board based on your special needs?\n\n\nHow to find whether it\ns working fine or not? \n LED indicators\n\uf0c1\n\n\nWe find it is the best way to indicate how the Sheild is performing by adding LED indicators for our customers. We have listed the LED indicators in the table below:\n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\nStatus\n\n\nHardware Connection\n\n\n\n\n\n\n\n\n\n\nD5\n\n\nGreen LED. Indicates the association status.\n\n\nOFF:\nmeans the module is not associated with a network.\nSolid ON:\nindicates that it is associated and Internet access is OK\n\n\nConnected to GPIO6 of the RN171 module\n\n\n\n\n\n\nD1\n\n\nRed LED. Indicates the TCP/IP connection status.\n\n\nSolid ON: \nconnected over TCP.\nFast Toggle (2 times/second): \nNo IP address or module is in command mode.\nSlow Toggle (once/second):\nIP address is OK.\n\n\nConnected to GPIO4 of the RN171 module\n\n\n\n\n\n\nRST\n\n\nRed LED. WiFi module reset status.\n\n\nSolid ON:\n The reset button (WIFI_RST) is been pressed.\n\n\nConnected to Reset of the RN171 module.\n\n\n\n\n\n\nPWR\n\n\nGreen LED. \nIndicates WiFi module\ns power up status.\n\n\nSolid ON:\n \nThe module/shield is powered up.\n\n\nConnected to the 3.3V output of the LD1117 voltage regulator.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nThe GPIO6 pin of the RN171 WiFi module is by default only connected to the LED labeled D5 on the WiFi shield. This LED is used to display the status of the Access Point (AP) \nconnection. If however, you would like to connect GPIO6 to digital pin 5 of the Arduino, simply solder the pad labeled \nP6\n on the WiFi shield.\n\n\n\n\nWIFI SHIELD V2.0 TUTORIAL\n\uf0c1\n\n\nbasic functions:\n\uf0c1\n\n\njoin()\n\uf0c1\n\n\n\n\nDescription:\n\n\nUsed to join a WiFi access point\n\n\n\n\n\n\nSyntax:\n\n\njoin(const char \nssid, const char \nphrase, int auth)\n\n\n\n\n\n\nParameters:\n\n\nssid:\n The name of the access point you want the shield to connect to\n\n\nphrase:\n The password/phrase of the access point you want the shield to connect to\n\n\nauth:\n The authentication type of the access point you want the shield to connect to. Can be one of the following constants:\n\n\nWIFLY_AUTH_OPEN\n\n\nWIFLY_AUTH_WEP\n\n\nWIFLY_AUTH_WPA1\n\n\nWIFLY_AUTH_WPA1_2\n\n\nWIFLY_AUTH_WPA2_PSK\n\n\nWIFLY_AUTH_ADHOC\n\n\n\n\n\n\n\n\n\n\nReturns:\n\n\nboolean:\n true if the connection to the access point was successful, false otherwise.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nThe examples is based on Arduino UNO and we take D2/D3 as the SoftwareSerial pins. If you are using an Arduino Mega, D2 is not available anymore. More details please refer to \nArduino Software Serial\n\nHere\ns an example.\n\n\n\n\n\n\nreceive()\n\uf0c1\n\n\n\n\nDescription:\n\n\nCan be used to read data from the shield, an alternative for the Arduino\ns read() function.\n\n\n\n\n\n\nSyntax:\n\n\nreceive(uint8_t *buf, int len, int timeout)\n\n\n\n\n\n\nParameters:\n\n\nbuf:\n A buffer array where the bytes read from the shield is stored.\n\n\nlen:\n The length/size of the buffer array\n\n\ntimeout:\n A timeout value to know when to stop trying to read.\n\n\n\n\n\n\nReturns:\n\n\nint:\n The number of bytes read from the shield.\n\n\n\n\n\n\nExample:\n\n\n\n\nchar c;\nwhile (wifly.receive((uint8_t *)\nc, 1, 300) \n 0) {\n    Serial.print((char)c);\n}\n\n\n\n\nsendCommand()\n\uf0c1\n\n\n\n\nDescription:\n\n\nSome our functions (e.g. join(), reboot(), save()) act as wrappers for the text commands listed in the user manual of the RN171 module. The function sendCommand() allows you to come up with your own wrapper function if ours do not meet your needs.\n\n\n\n\n\n\nSyntax:\n\n\nsendCommand(const char \ncmd, const char \nack, int timeout)\n\n\n\n\n\n\nParameters:\n\n\ncmd:\n Any command from the RN-171\ns user manual.\n\n\nack:\n The expected return string from the command\n\n\ntimeout:\n The time allowed before considering the output a bad request/response\n\n\n\n\n\n\n\n\nReturns:\n\n\n\n\nboolean:\n true if the WiFi shield responded with the ack string, false otherwise.\n\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\n// our join() function is wrapper for the join command, as seen below.\n//The string \nAssociated\n is what the user manual says the RN171 will return on success.\nif(sendCommand(\njoin\\r\n, \nAssociated\n,DEFAULT_WAIT_RESPONSE_TIME*10))\n{\n    // joined\n}else{\n    // not able to join\n}\n\n\n\n\nBASIC EXAMPLE\n\uf0c1\n\n\nExample 1 [EASY]: connect to your home WIFI\n\uf0c1\n\n\nSee File-\nExamples-\nWiFi_Shield-\nwifly_test sketch for a complete example.\n\n\n\nExample 2 [EASY]: send command to \nWIFI_SHIELD_V2.0\n and Receive Response Via Arduino Serial Monitor\n\uf0c1\n\n\nThis example will show you how a device such as your PC and/or phone may talk to the WiFi shield.\n\n\nFollow these steps:\n\n\n\n\nConfigure the module with step1-7 in Example 2\ns section \nConnecting By Typing Commands\n\n\nSet the listening IP port to \n80\n by sending the commands \nset ip local 80\n\n\nConnect/Join your shield to an access point as shown in the step 8 in Example 2\ns section \nConnecting By Typing Commands\n\n\nSave these setting by sending the \nsave\n command\n\n\nGet the IP address of your shield with the command \nget ip\n. The IP address and port will be displayed to the right of \nIP=\n in the response (e.g. IP=192.168.0.10:80)\n\n\nOpen your web browser and type your shield\ns IP address in your web browser\ns URL bar and press Enter to visit it.\n\n\nYour Arduino\ns serial monitor window will display an HTTP response similar to the one below. This is the information that your browser sent to the shield to request data.\n\n\n\n\n*OPEN*GET / HTTP/1.1\nHost: 192.168.0.10\nConnection: keep-alive\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36\nAccept-Encoding: gzip, deflate, sdch\nAccept-Language: en-US,en;q=0.8\n\n\n\n\nThe browser is now waiting for data, the Wifi module can send sensor values, serve web pages, or any other data straight back to the browser! In this case, the browser is waiting for a web page. If the Wifi module responds with an HTML-formatted page, the browser will display it. The next examples will teach you how to do all this fun stuff.\n\n\nexample 3 [EASY]: send an HTTP request from your PC to your \nWIFI_SHIELD_V2.0\n\uf0c1\n\n\nIn this example we will show you how to connect the WiFi shield to an access point (your internet router) with and without you typing the commands required:\n\n\nConnecting By Typing Commands\n\uf0c1\n\n\nThis section will teach you how to connect the WiFi shield to an access point using commands from the RN-171 datasheet, by going through this section you will then know exactly what is happening in the background when you use our WiFi Arduino libraries.\n\n\nDo the following:\n\n\n\n\nUpload the code in Example One to your Arduino board\n\n\n\n\nEnter command mode:\n\n\n\n\nSet the serial monitor to \u201cNo line ending\u201d, baud rate to 9600.\n\n\nType \n$$$\n into the Arduino Serial Monitor and press enter.\n\n\n\n\n\n\n\n\nSet the serial monitor to \u201cCarriage return\u201d.\n\n\n\n\n\n\nScan for available access points:\n\n\n\n\nType \nscan\n and press enter. The Arduino serial monitor window will output a list of comma separated values for each access point the WiFi shield has found. From left to right the third value is the security mode, the last value is the SSID. This example shows a security mode of 4 with an SSID name MySSID: 01,01,-88,\n04\n,1104,1c,00,45:56:78:be:93:1f,\nMySSID\n\n\n\n\n\n\n\n\nFrom the list of access points found, find the one which corresponds to your internet router and note the security mode, and SSID as we will need these two values to connect to it.\n\n\n\n\n\n\nSet the security mode in the shield:\n\n\n\n\nType \nset wlan auth m\n. Replace \nm\n with the security mode number (in this example that would be 4) of the access point you wish to connect to.\n\n\nThe security modes supported by the WiFi shield are listed in Figure 1 below.\n\n\n\n\n\n\n\n\nSet the access point phrase\n\n\n\n\n\n\nType \nset wlan phrase myPhrase\n. Replace \nmyPhrase\n with your access point\ns password/security key. \n\n\n\nNote\n\nIf your access point\ns security type is WEP use \nkey\n instead of \nphrase\n in the command above.\n\n\n\n\n\n\n\nThe access point\ns (internet router) phrase is the password you use to connect to it from your PC. In Windows you can find it as shown in the animated image below:\n    \n\n    How to find a networks\n security key/password\n\n\n\n\n\n\n\n\n\n\nJoin the access point\n\n\n\n\nNow that we have set the security type and phrase of the access point, we may connect to it.\n\n\nType \njoin MySSID\n. Replace MySSID with your access point\ns broadcast name.\n\n\nThe word \nAssociated!\n will be displayed in the Arduino serial monitor window if successful.\n\n\n\n\n\n\n\n\nA description of the commands you entered in the steps above is available in the table below. A more detailed description of each command can be found in the RN171\ns user manual.\n\n\n\n\n\n\n\n\nNumber\n\n\nCommands\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n1\n\n\nscan\n\n\nThis command performs an active probe scan of access points on all 13 channels. When you use this command, the module returns the MAC address, signal strength, SSID name, and security mode of the access points it finds.\n\n\n\n\n\n\n2\n\n\nset wlan auth 4\n\n\nFind the value that corresponds to the security protocol on your access point. Then, tell the WiFly what security protocol to use, it is the number shown in \nFigure 1\n that corresponds to the access point\ns security protocol. Here we choose \u201c4\u201d.\n\n\n\n\n\n\n3\n\n\nset wlan phrase seeed-mkt\n\n\nTell the WiFi shield your passphrase.\n\n\n\n\n\n\n4\n\n\njoin SEEED-MKT\n\n\nTell the WiFi shield to join, \u201cSEEED-MKT\u201c is the name of the access point we choose to connect. After sending the command the module should now connect and print out information about the connection. (If the connection is failed, try to send the command again until it works )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nValue\n\n\nAuthentication Mode\n\n\n\n\n\n\n\n\n\n\n0\n\n\nOpen (Default)\n\n\n\n\n\n\n1\n\n\nWEP-128\n\n\n\n\n\n\n2\n\n\nWPA1\n\n\n\n\n\n\n3\n\n\nMixed WPA1 and WPA2-PSK\n\n\n\n\n\n\n4\n\n\nWPA2-PSK\n\n\n\n\n\n\n5\n\n\nNot used\n\n\n\n\n\n\n6\n\n\nAD hoc mode (join any ad hoc network)\n\n\n\n\n\n\n8\n\n\nWPE-64\n\n\n\n\n\n\n\n\nFigure 1\n\n\nConnecting Using Our WiFi Libraries\n\uf0c1\n\n\nNow that you know how to connect to an access point by typing each command it\ns time to use the libraries and examples we provide.\n\n\nTo see code required to connect to an access point go to \u201cFile -\n Examples -\n Wifi_Shield -\n wifi_test\u201d. Change the code to use your own SSID (access point name), and KEY (your access point\ns password), then upload the sketch to your Arduino IDE.\n\n\n#define SSID      \" SEEED-MKT \"\n#define KEY       \" seeed-mkt \"\n\n\n\nWith the sketch uploaded to your Arduino board, open the serial monitor window. If the shield was successful in joining the access point an \nOK\n message will be displayed along with the connection information resulting from the \nget everything\n command. If the shield failed to join the access point a \nFailed\n message will be displayed.\n\n\nConfiguring The Shield to Connect On Power-Up\n\uf0c1\n\n\nThe shield can be configured to connect on power up, you only have to do this once:\n\n\n\n\nSend the \nset wlan ssid mySSID\n command replacing mySSID with your SSID\n\n\nSend the \nset wlan join 1\n command.\n\n\nSend the \nsave\n command.\n\n\n\n\nNow the shield will connect to the access point automatically on power up.\n\n\nA description of what each command does can be found in the RN-171 datasheet and in the table below.\n\n\n\n\n\n\n\n\nNumber\n\n\nCommands\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n1\n\n\nset wlan ssid \n\n\n is the name of the access point you\nd like to connect to automatically\n\n\n\n\n\n\n2\n\n\nset wlan join 1\n\n\nThis tells the module to try and connect to the SSID stored in memory automatically.\n\n\n\n\n\n\n3\n\n\nsave\n\n\nStore/Save these settings in the Wifi\ns config file\n\n\n\n\n\n\n\n\nSetting a Static IP Address\n\uf0c1\n\n\nTo have the shield obtain a static IP address from the access point, once connected to the access point, send the following commands:\n\n\n\n\n\n\n\n\nNumber\n\n\nCommands\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n1\n\n\nset ip dhcp 0\n\n\nTurn of DHCP .\n\n\n\n\n\n\n2\n\n\nset ip address \n\n\nSet the IP address you want .\n\n\n\n\n\n\n\n\nExample 4 [EASY]: Adhoc Mode\n\uf0c1\n\n\nTo use the shield in Adhoc mode, as an access point, simply connect pin IO9 from the shield to the 3.3V pin in the Arduino, as shown below, and reset the shield if it was on.\n\n\n\n\nShield connection required for adhoc mode. Pin IO9 of the shield connected to 3.3V.\n\n\nTo obtain the shield\ns SSID upload the code in Example 1 to your Arduino and open the serial monitor, the shield will respond with it\ns SSID as in the example below, where in this case \nWiFly-EZX-1b\n is the SSID.\n\n\nAP mode as WiFly-EZX-1b on chan 1\n\n\n\nYou should now be able to connect to your WiFi shield as an access point, for example the SSID should be visible in your PC\ns list of WiFi networks available.\n\n\nTo learn more about adhoc mode check out the \nWiFly RN User Manual\n section 16 \nAdhoc Networking Mode\n\n\nExample 5 [MID]: TCP Communication With Terminal\n\uf0c1\n\n\nIn this example we\nll show you how to send information from the WiFi shield to a PC terminal program. We\nll make a simple Arduino console with menus that will give you the option to see the Arduino digital pin\ns state and toggle them.\n\n\nStep 1: Download a TCP Terminal\n\n\nDownload and install RealTerm\n, a utility terminal that will allow us to connect to the WiFi shield.\n\n\nStep 2: Arduino Code\n\n\nUpload the code below to your Arduino board replacing \nmySSID\n, \nmyPassword\n, and authentication code with your own access point\ns information:\n\n\n\n    #include \nSoftwareSerial.h\n\n    #include \nWiFly.h\n\n\n    #define SSID      \nmySSID\n\n    #define KEY       \nmyPassword\n\n// check your access point's security mode, mine was WPA20-PSK\n// if yours is different you'll need to change the AUTH constant, see the file WiFly.h for avalable security codes\n    #define AUTH      WIFLY_AUTH_WPA2_PSK\n\n    #define FLAG_MAIN_MENU 1\n    #define FLAG_SUB_MENU_2 2\n\nint flag = FLAG_MAIN_MENU;\n\n// Pins' connection\n// Arduino       WiFly\n//  2    \n----\n    TX\n//  3    \n----\n    RX\n\nSoftwareSerial wiflyUart(2, 3); // create a WiFi shield serial object\nWiFly wifly(\nwiflyUart); // pass the wifi siheld serial object to the WiFly class\n\nvoid setup()\n{\n\n    // define the pins we can control\n    pinMode(11,OUTPUT);\n    digitalWrite(11,LOW);\n\n    pinMode(12,OUTPUT);\n    digitalWrite(12,LOW);\n\n    pinMode(13,OUTPUT);\n    digitalWrite(13,LOW);\n\n    pinMode(7,OUTPUT);\n    digitalWrite(7,LOW);\n\n    wiflyUart.begin(9600); // start wifi shield uart port\n\n    Serial.begin(9600); // start the arduino serial port\n    Serial.println(\n--------- TCP Communication --------\n);\n\n    // wait for initilization of wifly\n    delay(1000);\n\n    wifly.reset(); // reset the shield\n    delay(1000);\n\n    wifly.sendCommand(\nset ip local 80\\r\n); // set the local comm port to 80\n    delay(100);\n\n    wifly.sendCommand(\nset comm remote 0\\r\n); // do not send a default string when a connection opens\n    delay(100);\n\n    wifly.sendCommand(\nset comm open *\\r\n); // set the string or character that the wifi shield will output when a connection is opened \n*\n\n    delay(100);\n\n    wifly.sendCommand(\nset ip protocol 2\\r\n); // set TCP protocol\n    delay(100);\n\n    Serial.println(\nJoin \n SSID );\n    if (wifly.join(SSID, KEY, AUTH)) {\n        Serial.println(\nOK\n);\n    } else {\n        Serial.println(\nFailed\n);\n    }\n\n    wifly.sendCommand(\nget ip\\r\n);\n    char c;\n\n    while (wifly.receive((uint8_t *)\nc, 1, 300) \n 0) { // print the response from the get ip command\n        Serial.print((char)c);\n    }\n\n    Serial.println(\nTCP Ready\n);\n}\n\nvoid loop()\n{\n\n    if(wifly.available())\n    {\n        delay(1000); // wait for all the characters to be sent to the WiFi shield\n        char val = wiflyUart.read(); // read the first character\n\n        if(flag == FLAG_MAIN_MENU)\n        {\n            switch(val)\n            {\n                case '*': // search for the new connection string\n                printMainMenu();\n                break;\n                case '1': // the user typed 1, display the pin states\n                printPinStates();\n                printMainMenu();\n                break;\n                case '2': // the user typed 2, display the sub menu (option to select a particular pin)\n                printSubMenu2();\n                flag = FLAG_SUB_MENU_2; // flag to enter the sub menu\n                break;\n                default:\n                wiflyUart.print(\nINVALID SUBMENU\\r\\n\n);\n                break;\n            }\n        }\n        else if(flag == FLAG_SUB_MENU_2)\n        {\n            int pinNumber = val-48; // get first number i.e. if the pin 13 then the 1st number is 1\n            int secondNumber = (wiflyUart.read()-48);\n            if(secondNumber\n=0 \n secondNumber\n=9)\n            {\n                pinNumber*=10;\n                pinNumber +=secondNumber; // get second number, i.e. if the pin number is 13 then the 2nd number is 3, then add to the first number\n            }\n\n            // Create the \nYou want to toggle pin x?? OK...\n string.\n            String response = \n\\r\\nYou want to toggle pin \n;\n            response+=pinNumber;\n            response+=\n? OK...\\r\\n\n;\n\n            wiflyUart.print(response);\n\n            digitalWrite(pinNumber, !digitalRead(pinNumber)); // toggle pin\n\n            wiflyUart.print(\nPin Toggled!\\r\\n\n); // let user know the pin was toggled.\n            printMainMenu();\n            flag = FLAG_MAIN_MENU;\n        }\n    }\n\n}\n\n    /*\n    * Prints the main menu options\n    */\nvoid printMainMenu()\n{\n    wiflyUart.print(\n\\r\\n\\r\\n\n);\n    wiflyUart.print(\nArduino Console Menu: \\r\\n\n);\n    wiflyUart.print(\n1. Show digital pin states\\r\\n\n);\n    wiflyUart.print(\n2. Toggle a digital pin's state\\r\\n\n);\n    wiflyUart.print(\n\\r\\n\\r\\n\n);\n}\n\n// displays the pin states\nvoid printPinStates()\n{\n\n    String pinState = \nPin 7 is \n;\n    pinState+=getPinState(7);\n    pinState+=\n\\r\\n\n;\n\n    pinState += \nPin 11 is \n;\n    pinState+=getPinState(11);\n    pinState+=\n\\r\\n\n;\n\n    pinState += \nPin 12 is \n;\n    pinState+=getPinState(12);\n    pinState+=\n\\r\\n\n;\n\n    pinState += \nPin 13 is \n;\n    pinState+=getPinState(13);\n    pinState+=\n\\r\\n\n;\n\n    wiflyUart.print(pinState);\n}\n\n// prints the option to enter a pin number\nvoid printSubMenu2()\n{\n    wiflyUart.print(\n\\r\\nEnter the pin number you wish to toggle: \n);\n}\n?\n// get a pin state as a string.\nString getPinState(int pinNumber)\n{\n    if(digitalRead(pinNumber)) // check if the pin is ON or OFF\n    {\n        return \nON\n; // the pin is on\n    }\n    else\n    {\n        return \nOFF\n;  // the pin is off\n    }\n}\n\n\n\n\nStep 3: Obtain the Shield\ns IP Address and Port\n\n\nOpen the Arduino serial monitor window to obtain the WiFiShield\ns IP address and port number, highlighted in the image below.\n\n\n\n\nArduino serial monitor window output from TCP example, the ip address and port number are highlighted.\n\n\nIn the image above the IP Address and Port would be the following:\n\n\n192.168.0.10:80\n\n\n\nStep 4: Configure The TCP Terminal and Connect to The Shield\n\n\nOpen RealTerm and in the \nDisplay\n tab enter \n30\n for \nRows\n and select the \nScrollback\n option:\n\n\n\n\nRealTerm window: rows = 30, and Scrollback option checked.\n\n\nIn the \nPort\n tab of the RealTerm program, type your shield\ns IP address and port e.g. 192.168.0.10:80, then click the \nOpen\n button, the Arduino\ns hard coded main menu should display in the terminal.\n\n\n\n\nRealTerm window. Port field has WiFi shield\ns IP address and port number. The Arduino\ns menu is displayed\n\n\nIn the \nSend\n tab select one of the options from the menu either \n1\n or \n2\n, enter it in the text box and press \nSend ASCII\n to send the value.\n\n\nFor example, to toggle pin 13 enter \n2\n and press \nSend ASCII\n, then when prompted \nEnter the pin number you wish you toggle\n enter \n13\n and click \nSend ASCII\n. The Arduino should reply \nPin Toggled!\n and go back to the main menu, now enter \n1\n and press \nSend ASCII\n to see the present state of the pins.\n\n\n\n\nRealTerm window. The state of pin 13 was changed from OFF to ON as shown in the yellow text.\n\n\nAdvanced example\n\uf0c1\n\n\nProject 1 [MID]: Use Web/Android APP to control the LED\n\uf0c1\n\n\nStep One: Arduino Code\n\n\nUpload the following code to your Arduino board replacing \nmyssid\n and \nmypassword\n with your accesspoint\ns values respectively:\n\n\n    #include \nSoftwareSerial.h\n\n    #include \nWiFly.h\n\n\n    #define SSID      \nmyssid\n\n    #define KEY       \nmypassword\n\n// check your access point's security mode, mine was WPA20-PSK\n// if yours is different you'll need to change the AUTH constant, see the file WiFly.h for avalable security codes\n    #define AUTH      WIFLY_AUTH_WPA2_PSK\n\nint flag = 0;\n\n// Pins' connection\n// Arduino       WiFly\n//  2    \n----\n    TX\n//  3    \n----\n    RX\n\nSoftwareSerial wiflyUart(2, 3); // create a WiFi shield serial object\nWiFly wifly(\nwiflyUart); // pass the wifi siheld serial object to the WiFly class\n\nvoid setup()\n{\n    wiflyUart.begin(9600); // start wifi shield uart port\n    Serial.begin(9600); // start the arduino serial port\n    Serial.println(\n--------- WIFLY Webserver --------\n);\n\n    // wait for initilization of wifly\n    delay(1000);\n\n    wifly.reset(); // reset the shield\n    delay(1000);\n    //set WiFly params\n\n    wifly.sendCommand(\nset ip local 80\\r\n); // set the local comm port to 80\n    delay(100);\n\n    wifly.sendCommand(\nset comm remote 0\\r\n); // do not send a default string when a connection opens\n    delay(100);\n\n    wifly.sendCommand(\nset comm open *OPEN*\\r\n); // set the string that the wifi shield will output when a connection is opened\n    delay(100);\n\n    Serial.println(\nJoin \n SSID );\n    if (wifly.join(SSID, KEY, AUTH)) {\n        Serial.println(\nOK\n);\n    } else {\n        Serial.println(\nFailed\n);\n    }\n\n    wifly.sendCommand(\nget ip\\r\n);\n    char c;\n\n    while (wifly.receive((uint8_t *)\nc, 1, 300) \n 0) { // print the response from the get ip command\n        Serial.print((char)c);\n    }\n\n    Serial.println(\nWeb server ready\n);\n\n}\n\nvoid loop()\n{\n\n    if(wifly.available())\n    { // the wifi shield has data available\n        if(wiflyUart.find(\n*OPEN*\n)) // see if the data available is from an open connection by looking for the *OPEN* string\n        {\n            Serial.println(\nNew Browser Request!\n);\n            delay(1000); // delay enough time for the browser to complete sending its HTTP request string\n            // send HTTP header\n            wiflyUart.println(\nHTTP/1.1 200 OK\n);\n            wiflyUart.println(\nContent-Type: text/html; charset=UTF-8\n);\n            wiflyUart.println(\nContent-Length: 244\n); // length of HTML code\n            wiflyUart.println(\nConnection: close\n);\n            wiflyUart.println();\n\n            // send webpage's HTML code\n            wiflyUart.print(\nhtml\n);\n            wiflyUart.print(\nhead\n);\n            wiflyUart.print(\ntitle\nMy WiFI Shield Webpage\n/title\n);\n            wiflyUart.print(\n/head\n);\n            wiflyUart.print(\nbody\n);\n            wiflyUart.print(\nh1\nHello World!\n/h1\n);\n            wiflyUart.print(\nh3\nThis website is served from my WiFi module\n/h3\n);\n            wiflyUart.print(\na href=\\\nhttp://yahoo.com\\\nYahoo!\n/a\n \na href=\\\nhttp://google.com\\\nGoogle\n/a\n);\n            wiflyUart.print(\nbr/\nbutton\nMy Button\n/button\n);\n            wiflyUart.print(\n/body\n);\n            wiflyUart.print(\n/html\n);\n        }\n    }\n}\n\n\n\n\nStep Two: Get the Shield\ns IP Address\n\n\nOpen the serial monitor window and wait for the \nWeb server ready\n message to display. The serial monitor will also display the WiFi shield\ns IP address:\n\n\n\n\nArduino program serial comm output. The IP address of the shield is highlighted.\n\n\nStep Three: Visiting the webpage\n\n\nNow visit that IP address in your web browser. The webpage below should be displayed, it contains a link to Yahoo! and Google and a button that doesn\nt do anything (yet):\n\n\n\n\nA simple webpage with two links and one button served from the WiFi shield.\n\n\nWhen the webpage is visited the serial monitor window will also display a \nNew Browser Request!\n string as shown below:\n\n\n\n\nThe Arduino serial comm window showing that it detected a new browser connection/request.\n\n\n\n\nNote\n\nIn case of some browsers, like Google Chrome, even typing the URL in the bar sends a webpage request, this is because these browsers try to get the webpage's title for the user's convenience even before he/she visits the webpage.\n\n\n\n\n\n\nProject 2 [HARD]: Get the weather data from the external web server\nThe RN-171 module in the WiFi shield has the ability to act as an HTML client (a text based web browser essentially), this means that we can use the shield to send and receive data from a web server. In this example you will learn to use the shield with a web Application Programming Interface (API) that displays any city\ns weather data (i.e. temperature, humidity, etc).\n\n\n\n\nThe name of the API we\nll use is \nOpenWeatherMap\n, when you send the name of a city and country to this website it returns a JSON string with weather information.  If you want to display the weather for London UK for example, please refer to the toturial in this link http://openweathermap.org/appid .Starting from 9 Oct 2015, the website requires users to sign up for a API key before visiting the API. Once you have got the API key, you will be able to visit the following URL http://api.openweathermap.org/data/2.5/weather?q=London,uk which would return a JSON string like the following, where the weather data and other information is embedded.\n\n\n{\n    \ncoord\n:{\nlon\n:-0.13,\nlat\n:51.51},\n    \nsys\n:{\ntype\n:3,\nid\n:60992,\nmessage\n:0.0079,\ncountry\n:\nGB\n,\nsunrise\n:1421395087,\nsunset\n:1421425352},\n    \nweather\n:[{\nid\n:802,\nmain\n:\nClouds\n,\ndescription\n:\nscattered clouds\n,\nicon\n:\n03n\n}],\n    \nbase\n:\ncmc stations\n,\n    \nmain\n:{\n        \ntemp\n:277.25,\nhumidity\n:79,\npressure\n:998.4,\n        \ntemp_min\n:277.25,\ntemp_max\n:277.25\n    },\n    \nwind\n:{\n    \nspeed\n:2,\ngust\n:5,\ndeg\n:180},\n    \nrain\n:{\n3h\n:0},\nclouds\n:{\nall\n:32},\n    \ndt\n:1421372140,\nid\n:2643743,\nname\n:\nLondon\n,\ncod\n:200\n}\n\n\n\n\nStep 1: The URL\n\n\nLet us go ahead and retrieve the weather JSON string for San Francisco, US. The URL our WiFi shield needs to visit is the following (you may test it in your web browser):\n\n\nhttp://api.openweathermap.org/data/2.5/weather?q=San%20Francisco,US\n\n\n\nStep 2: The Arduino Code\n\n\nSection 13 of the \nWiFly manual\n teaches you different ways to connect to a web server, but in all cases we need to specify the name of the server (or IP address if the server does not have a domain name), and then the data we wish to send.\n\n\nThe commands we need to send to the WiFi shield to receive the JSON string from the OpenWeatherMap server are the following:\n\n\nset ip proto 18 //enable html client\nset dns name api.openweathermap.org //name of your webserver\nset ip address 0 // so WiFly will use DNS\nset ip remote 80 // standard webserver port\nset com remote 0 // turn off the REMOTE string so it does not interfere with the post \nopen // to open the connection\nGET /data/2.5/weather?q=San%20Francisco,US \\n\\n // to send the data\n\n\n\nThis is the arduino code that will send the commands:\n\n\n    #include \nSoftwareSerial.h\n\n    #include \nWiFly.h\n\n\n    #define SSID      \nmySSID\n\n    #define KEY       \nmyPassword\n\n// check your access point's security mode, mine was WPA20-PSK\n// if yours is different you'll need to change the AUTH constant, see the file WiFly.h for avalable security codes\n    #define AUTH      WIFLY_AUTH_WPA2_PSK\n\n// Pins' connection\n// Arduino       WiFly\n//  2    \n----\n    TX\n//  3    \n----\n    RX\n\nSoftwareSerial wiflyUart(2, 3); // create a WiFi shield serial object\nWiFly wifly(\nwiflyUart); // pass the wifi siheld serial object to the WiFly class\n\nvoid setup()\n{\n    wiflyUart.begin(9600); // start wifi shield uart port\n    Serial.begin(9600); // start the arduino serial port\n    Serial.println(\n--------- OpenWeatherMap API --------\n);\n\n    // wait for initilization of wifly\n    delay(3000);\n    wifly.reset(); // reset the shield\n    Serial.println(\nJoin \n SSID );\n    if (wifly.join(SSID, KEY, AUTH)) {\n        Serial.println(\nOK\n);\n    } else {\n        Serial.println(\nFailed\n);\n    }\n\n    wifly.sendCommand(\nset ip proto 18\\r\n); //enable html client\n    delay(100);\n\n    wifly.sendCommand(\nset dns name api.openweathermap.org\\r\n); // name of the webserver we want to connect to\n    delay(100);\n\n    wifly.sendCommand(\nset ip address 0\\r\n); // so WiFly will use DNS\n    delay(100);\n\n    wifly.sendCommand(\nset ip remote 80\\r\n); /// standard webserver port\n    delay(100);\n\n    wifly.sendCommand(\nset com remote 0\\r\n); // turn off the REMOTE string so it does not interfere with the post\n    delay(100);\n\n    wifly.sendCommand(\nopen\\r\n); // open connection\n    delay(100);\n\n    wiflyUart.print(\nGET /data/2.5/weather?q=San%20Francisco,US \\n\\n\n);\n    delay(1000);\n\n}\n\nvoid loop()\n{\n    //As soon as the data  received from the Internet ,output the data through the UART Port .\n    while (wifly.available())\n    {\n        Serial.write(wifly.read());\n    }\n}\n\n\n\n\nStep 3: Result\n\n\nOpen the serial monitor window, you should be able to see the same JSON string you saw in the browser.\n\n\n\n\nJSON weather string shown in the Arduino serial monitor window.\n\n\nResources\n\uf0c1\n\n\n\n\nWiFi Shield V2.0 Eagle Files\n\n\nSchematic PDF\n\n\nRN-171 Datasheet\n\n\nWifi Shield Library\n\n\nWiFi Module User Manual\n \n This is where you\nll find all the commands for the RN-171 module in the shield.\n\n\nWhat is a Seeeduino\n\n\nw3schools\n Great website to learn HTML, Javascript, and JQuery", 
            "title": "Wi-Fi Shield"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#basic-information", 
            "text": "this module name is  Wifi Shield V2.0 , that enables your Arduino/Seeeduino board with the cool wifi connection capability. Equipped with the RN171 module, which is a complete standalone TCP/IP wireless \nnetwork module. We choose it all because it is prefect for wireless application such as assets monitoring, sensors, and portable battery operated devices. We are looking forward to the products you could \nbuild with our  Wifi Shield V2.0  leverage its incredible low power consumption, and awesome configurable transmit power that you could adjust the signal power strong or weak based on your user cases.", 
            "title": "BASIC INFORMATION"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#whats-new", 
            "text": "Seeedstudio always cares about your hacking experience, saving your energy on wiring and unnecessary accessories so that you could focus on core applications really matters. Our hardware team shapes the  Wifi Shield V2.0  with Standard Shield and on-board antenna, so that you could  plug and play  with our amazing  Wifi Shield V2.0 . Our on-board antenna allows the shield to cover a wider range and \ntransmit stronger signals. Our  Wifi Shield V2.0  supports TCP, UDP, FTP, and HTTP communication protocols to meet the needs of most wireless and Internet of Things (IoT) network projects e.g. smart home \nnetworks, robots control, personal weather stations.", 
            "title": "WHAT'S NEW"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#hardware-overview", 
            "text": "Tip  The operating voltage of the RN-171 module is  3.3V DC typically, so a voltage regulator and logic level translator are designed on the WiFi shield. The LD1117 regulator on the shield converts to 3.3VDC, which supplies the RN171 module. However, due to the auto judgement schematic of power supply, the RN-171 can be powered via both 3V3 pin and 5V pin. But the supply power would be 5v if providing both 3.3v and 5v to the board. If using with an Arduino/Seeeduino board simply stack the WiFi shield on the board.", 
            "title": "HARDWARE OVERVIEW"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#why-choose-us", 
            "text": "Seeedstudio is one of the largest open source hardware distributors, with high quality, cost effective, varies of open source products and great customer services. And most important we care about every \ncustomer. We are willing to learn from you and improve your every hacking experience by making perfect products of our time.", 
            "title": "WHY CHOOSE US"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#what-makes-this-product-different-from-others", 
            "text": "Among all of the Arduino Shields in the market,  Wifi Shield V2.0  is one of a kind. It s the combination of conciseness and multi-functionality that we could have so many function just in one Shield with\nall of the flexibilities. It s such a good deal to enable your Arduino applications with this cost effective solution, so that you could easily scale out your products with a more competitive price point.", 
            "title": "what makes this product different from others"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#how-to-use", 
            "text": "As we just said, it s very easy to get start with the  Wifi Shield V2.0 . We have provided a helpful library to assist you to interact with the Wifi Shield, with examples to let you walk through the main \nfunctions of the Shield.", 
            "title": "HOW TO USE"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#basic-setup-steps", 
            "text": "First thing first, we need to understand the basics of the Shield. How to find whether it s working fine or not? How to configure the board based on your special needs?", 
            "title": "BASIC SETUP STEPS"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#how-to-find-whether-its-working-fine-or-not-led-indicators", 
            "text": "We find it is the best way to indicate how the Sheild is performing by adding LED indicators for our customers. We have listed the LED indicators in the table below:     Label  Description  Status  Hardware Connection      D5  Green LED. Indicates the association status.  OFF: means the module is not associated with a network. Solid ON: indicates that it is associated and Internet access is OK  Connected to GPIO6 of the RN171 module    D1  Red LED. Indicates the TCP/IP connection status.  Solid ON:  connected over TCP. Fast Toggle (2 times/second):  No IP address or module is in command mode. Slow Toggle (once/second): IP address is OK.  Connected to GPIO4 of the RN171 module    RST  Red LED. WiFi module reset status.  Solid ON:  The reset button (WIFI_RST) is been pressed.  Connected to Reset of the RN171 module.    PWR  Green LED.  Indicates WiFi module s power up status.  Solid ON:   The module/shield is powered up.  Connected to the 3.3V output of the LD1117 voltage regulator.      Tip  The GPIO6 pin of the RN171 WiFi module is by default only connected to the LED labeled D5 on the WiFi shield. This LED is used to display the status of the Access Point (AP) \nconnection. If however, you would like to connect GPIO6 to digital pin 5 of the Arduino, simply solder the pad labeled  P6  on the WiFi shield.", 
            "title": "How to find whether it's working fine or not? -- LED indicators"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#wifi-shield-v20-tutorial", 
            "text": "", 
            "title": "WIFI SHIELD V2.0 TUTORIAL"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#basic-functions", 
            "text": "", 
            "title": "basic functions:"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#join", 
            "text": "Description:  Used to join a WiFi access point    Syntax:  join(const char  ssid, const char  phrase, int auth)    Parameters:  ssid:  The name of the access point you want the shield to connect to  phrase:  The password/phrase of the access point you want the shield to connect to  auth:  The authentication type of the access point you want the shield to connect to. Can be one of the following constants:  WIFLY_AUTH_OPEN  WIFLY_AUTH_WEP  WIFLY_AUTH_WPA1  WIFLY_AUTH_WPA1_2  WIFLY_AUTH_WPA2_PSK  WIFLY_AUTH_ADHOC      Returns:  boolean:  true if the connection to the access point was successful, false otherwise.      Tip  The examples is based on Arduino UNO and we take D2/D3 as the SoftwareSerial pins. If you are using an Arduino Mega, D2 is not available anymore. More details please refer to  Arduino Software Serial \nHere s an example.", 
            "title": "join()"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#receive", 
            "text": "Description:  Can be used to read data from the shield, an alternative for the Arduino s read() function.    Syntax:  receive(uint8_t *buf, int len, int timeout)    Parameters:  buf:  A buffer array where the bytes read from the shield is stored.  len:  The length/size of the buffer array  timeout:  A timeout value to know when to stop trying to read.    Returns:  int:  The number of bytes read from the shield.    Example:   char c;\nwhile (wifly.receive((uint8_t *) c, 1, 300)   0) {\n    Serial.print((char)c);\n}", 
            "title": "receive()"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#sendcommand", 
            "text": "Description:  Some our functions (e.g. join(), reboot(), save()) act as wrappers for the text commands listed in the user manual of the RN171 module. The function sendCommand() allows you to come up with your own wrapper function if ours do not meet your needs.    Syntax:  sendCommand(const char  cmd, const char  ack, int timeout)    Parameters:  cmd:  Any command from the RN-171 s user manual.  ack:  The expected return string from the command  timeout:  The time allowed before considering the output a bad request/response     Returns:   boolean:  true if the WiFi shield responded with the ack string, false otherwise.     Example:    // our join() function is wrapper for the join command, as seen below.\n//The string  Associated  is what the user manual says the RN171 will return on success.\nif(sendCommand( join\\r ,  Associated ,DEFAULT_WAIT_RESPONSE_TIME*10))\n{\n    // joined\n}else{\n    // not able to join\n}", 
            "title": "sendCommand()"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#basic-example", 
            "text": "", 
            "title": "BASIC EXAMPLE"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#example-1-easy-connect-to-your-home-wifi", 
            "text": "See File- Examples- WiFi_Shield- wifly_test sketch for a complete example.", 
            "title": "Example 1 [EASY]: connect to your home WIFI"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#example-2-easy-send-command-to-wifi_shield_v20-and-receive-response-via-arduino-serial-monitor", 
            "text": "This example will show you how a device such as your PC and/or phone may talk to the WiFi shield.  Follow these steps:   Configure the module with step1-7 in Example 2 s section  Connecting By Typing Commands  Set the listening IP port to  80  by sending the commands  set ip local 80  Connect/Join your shield to an access point as shown in the step 8 in Example 2 s section  Connecting By Typing Commands  Save these setting by sending the  save  command  Get the IP address of your shield with the command  get ip . The IP address and port will be displayed to the right of  IP=  in the response (e.g. IP=192.168.0.10:80)  Open your web browser and type your shield s IP address in your web browser s URL bar and press Enter to visit it.  Your Arduino s serial monitor window will display an HTTP response similar to the one below. This is the information that your browser sent to the shield to request data.   *OPEN*GET / HTTP/1.1\nHost: 192.168.0.10\nConnection: keep-alive\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36\nAccept-Encoding: gzip, deflate, sdch\nAccept-Language: en-US,en;q=0.8  The browser is now waiting for data, the Wifi module can send sensor values, serve web pages, or any other data straight back to the browser! In this case, the browser is waiting for a web page. If the Wifi module responds with an HTML-formatted page, the browser will display it. The next examples will teach you how to do all this fun stuff.", 
            "title": "Example 2 [EASY]: send command to \"WIFI_SHIELD_V2.0\" and Receive Response Via Arduino Serial Monitor"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#example-3-easy-send-an-http-request-from-your-pc-to-your-wifi_shield_v20", 
            "text": "In this example we will show you how to connect the WiFi shield to an access point (your internet router) with and without you typing the commands required:", 
            "title": "example 3 [EASY]: send an HTTP request from your PC to your \"WIFI_SHIELD_V2.0\""
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#connecting-by-typing-commands", 
            "text": "This section will teach you how to connect the WiFi shield to an access point using commands from the RN-171 datasheet, by going through this section you will then know exactly what is happening in the background when you use our WiFi Arduino libraries.  Do the following:   Upload the code in Example One to your Arduino board   Enter command mode:   Set the serial monitor to \u201cNo line ending\u201d, baud rate to 9600.  Type  $$$  into the Arduino Serial Monitor and press enter.     Set the serial monitor to \u201cCarriage return\u201d.    Scan for available access points:   Type  scan  and press enter. The Arduino serial monitor window will output a list of comma separated values for each access point the WiFi shield has found. From left to right the third value is the security mode, the last value is the SSID. This example shows a security mode of 4 with an SSID name MySSID: 01,01,-88, 04 ,1104,1c,00,45:56:78:be:93:1f, MySSID     From the list of access points found, find the one which corresponds to your internet router and note the security mode, and SSID as we will need these two values to connect to it.    Set the security mode in the shield:   Type  set wlan auth m . Replace  m  with the security mode number (in this example that would be 4) of the access point you wish to connect to.  The security modes supported by the WiFi shield are listed in Figure 1 below.     Set the access point phrase    Type  set wlan phrase myPhrase . Replace  myPhrase  with your access point s password/security key.   Note \nIf your access point s security type is WEP use  key  instead of  phrase  in the command above.    The access point s (internet router) phrase is the password you use to connect to it from your PC. In Windows you can find it as shown in the animated image below:\n     \n    How to find a networks  security key/password      Join the access point   Now that we have set the security type and phrase of the access point, we may connect to it.  Type  join MySSID . Replace MySSID with your access point s broadcast name.  The word  Associated!  will be displayed in the Arduino serial monitor window if successful.     A description of the commands you entered in the steps above is available in the table below. A more detailed description of each command can be found in the RN171 s user manual.     Number  Commands  Description      1  scan  This command performs an active probe scan of access points on all 13 channels. When you use this command, the module returns the MAC address, signal strength, SSID name, and security mode of the access points it finds.    2  set wlan auth 4  Find the value that corresponds to the security protocol on your access point. Then, tell the WiFly what security protocol to use, it is the number shown in  Figure 1  that corresponds to the access point s security protocol. Here we choose \u201c4\u201d.    3  set wlan phrase seeed-mkt  Tell the WiFi shield your passphrase.    4  join SEEED-MKT  Tell the WiFi shield to join, \u201cSEEED-MKT\u201c is the name of the access point we choose to connect. After sending the command the module should now connect and print out information about the connection. (If the connection is failed, try to send the command again until it works )        Value  Authentication Mode      0  Open (Default)    1  WEP-128    2  WPA1    3  Mixed WPA1 and WPA2-PSK    4  WPA2-PSK    5  Not used    6  AD hoc mode (join any ad hoc network)    8  WPE-64     Figure 1", 
            "title": "Connecting By Typing Commands"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#connecting-using-our-wifi-libraries", 
            "text": "Now that you know how to connect to an access point by typing each command it s time to use the libraries and examples we provide.  To see code required to connect to an access point go to \u201cFile -  Examples -  Wifi_Shield -  wifi_test\u201d. Change the code to use your own SSID (access point name), and KEY (your access point s password), then upload the sketch to your Arduino IDE.  #define SSID      \" SEEED-MKT \"\n#define KEY       \" seeed-mkt \"  With the sketch uploaded to your Arduino board, open the serial monitor window. If the shield was successful in joining the access point an  OK  message will be displayed along with the connection information resulting from the  get everything  command. If the shield failed to join the access point a  Failed  message will be displayed.", 
            "title": "Connecting Using Our WiFi Libraries"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#configuring-the-shield-to-connect-on-power-up", 
            "text": "The shield can be configured to connect on power up, you only have to do this once:   Send the  set wlan ssid mySSID  command replacing mySSID with your SSID  Send the  set wlan join 1  command.  Send the  save  command.   Now the shield will connect to the access point automatically on power up.  A description of what each command does can be found in the RN-171 datasheet and in the table below.     Number  Commands  Description      1  set wlan ssid    is the name of the access point you d like to connect to automatically    2  set wlan join 1  This tells the module to try and connect to the SSID stored in memory automatically.    3  save  Store/Save these settings in the Wifi s config file", 
            "title": "Configuring The Shield to Connect On Power-Up"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#setting-a-static-ip-address", 
            "text": "To have the shield obtain a static IP address from the access point, once connected to the access point, send the following commands:     Number  Commands  Description      1  set ip dhcp 0  Turn of DHCP .    2  set ip address   Set the IP address you want .", 
            "title": "Setting a Static IP Address"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#example-4-easy-adhoc-mode", 
            "text": "To use the shield in Adhoc mode, as an access point, simply connect pin IO9 from the shield to the 3.3V pin in the Arduino, as shown below, and reset the shield if it was on.   Shield connection required for adhoc mode. Pin IO9 of the shield connected to 3.3V.  To obtain the shield s SSID upload the code in Example 1 to your Arduino and open the serial monitor, the shield will respond with it s SSID as in the example below, where in this case  WiFly-EZX-1b  is the SSID.  AP mode as WiFly-EZX-1b on chan 1  You should now be able to connect to your WiFi shield as an access point, for example the SSID should be visible in your PC s list of WiFi networks available.  To learn more about adhoc mode check out the  WiFly RN User Manual  section 16  Adhoc Networking Mode", 
            "title": "Example 4 [EASY]: Adhoc Mode"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#example-5-mid-tcp-communication-with-terminal", 
            "text": "In this example we ll show you how to send information from the WiFi shield to a PC terminal program. We ll make a simple Arduino console with menus that will give you the option to see the Arduino digital pin s state and toggle them.  Step 1: Download a TCP Terminal  Download and install RealTerm , a utility terminal that will allow us to connect to the WiFi shield.  Step 2: Arduino Code  Upload the code below to your Arduino board replacing  mySSID ,  myPassword , and authentication code with your own access point s information:  \n    #include  SoftwareSerial.h \n    #include  WiFly.h \n\n    #define SSID       mySSID \n    #define KEY        myPassword \n// check your access point's security mode, mine was WPA20-PSK\n// if yours is different you'll need to change the AUTH constant, see the file WiFly.h for avalable security codes\n    #define AUTH      WIFLY_AUTH_WPA2_PSK\n\n    #define FLAG_MAIN_MENU 1\n    #define FLAG_SUB_MENU_2 2\n\nint flag = FLAG_MAIN_MENU;\n\n// Pins' connection\n// Arduino       WiFly\n//  2     ----     TX\n//  3     ----     RX\n\nSoftwareSerial wiflyUart(2, 3); // create a WiFi shield serial object\nWiFly wifly( wiflyUart); // pass the wifi siheld serial object to the WiFly class\n\nvoid setup()\n{\n\n    // define the pins we can control\n    pinMode(11,OUTPUT);\n    digitalWrite(11,LOW);\n\n    pinMode(12,OUTPUT);\n    digitalWrite(12,LOW);\n\n    pinMode(13,OUTPUT);\n    digitalWrite(13,LOW);\n\n    pinMode(7,OUTPUT);\n    digitalWrite(7,LOW);\n\n    wiflyUart.begin(9600); // start wifi shield uart port\n\n    Serial.begin(9600); // start the arduino serial port\n    Serial.println( --------- TCP Communication -------- );\n\n    // wait for initilization of wifly\n    delay(1000);\n\n    wifly.reset(); // reset the shield\n    delay(1000);\n\n    wifly.sendCommand( set ip local 80\\r ); // set the local comm port to 80\n    delay(100);\n\n    wifly.sendCommand( set comm remote 0\\r ); // do not send a default string when a connection opens\n    delay(100);\n\n    wifly.sendCommand( set comm open *\\r ); // set the string or character that the wifi shield will output when a connection is opened  * \n    delay(100);\n\n    wifly.sendCommand( set ip protocol 2\\r ); // set TCP protocol\n    delay(100);\n\n    Serial.println( Join   SSID );\n    if (wifly.join(SSID, KEY, AUTH)) {\n        Serial.println( OK );\n    } else {\n        Serial.println( Failed );\n    }\n\n    wifly.sendCommand( get ip\\r );\n    char c;\n\n    while (wifly.receive((uint8_t *) c, 1, 300)   0) { // print the response from the get ip command\n        Serial.print((char)c);\n    }\n\n    Serial.println( TCP Ready );\n}\n\nvoid loop()\n{\n\n    if(wifly.available())\n    {\n        delay(1000); // wait for all the characters to be sent to the WiFi shield\n        char val = wiflyUart.read(); // read the first character\n\n        if(flag == FLAG_MAIN_MENU)\n        {\n            switch(val)\n            {\n                case '*': // search for the new connection string\n                printMainMenu();\n                break;\n                case '1': // the user typed 1, display the pin states\n                printPinStates();\n                printMainMenu();\n                break;\n                case '2': // the user typed 2, display the sub menu (option to select a particular pin)\n                printSubMenu2();\n                flag = FLAG_SUB_MENU_2; // flag to enter the sub menu\n                break;\n                default:\n                wiflyUart.print( INVALID SUBMENU\\r\\n );\n                break;\n            }\n        }\n        else if(flag == FLAG_SUB_MENU_2)\n        {\n            int pinNumber = val-48; // get first number i.e. if the pin 13 then the 1st number is 1\n            int secondNumber = (wiflyUart.read()-48);\n            if(secondNumber =0   secondNumber =9)\n            {\n                pinNumber*=10;\n                pinNumber +=secondNumber; // get second number, i.e. if the pin number is 13 then the 2nd number is 3, then add to the first number\n            }\n\n            // Create the  You want to toggle pin x?? OK...  string.\n            String response =  \\r\\nYou want to toggle pin  ;\n            response+=pinNumber;\n            response+= ? OK...\\r\\n ;\n\n            wiflyUart.print(response);\n\n            digitalWrite(pinNumber, !digitalRead(pinNumber)); // toggle pin\n\n            wiflyUart.print( Pin Toggled!\\r\\n ); // let user know the pin was toggled.\n            printMainMenu();\n            flag = FLAG_MAIN_MENU;\n        }\n    }\n\n}\n\n    /*\n    * Prints the main menu options\n    */\nvoid printMainMenu()\n{\n    wiflyUart.print( \\r\\n\\r\\n );\n    wiflyUart.print( Arduino Console Menu: \\r\\n );\n    wiflyUart.print( 1. Show digital pin states\\r\\n );\n    wiflyUart.print( 2. Toggle a digital pin's state\\r\\n );\n    wiflyUart.print( \\r\\n\\r\\n );\n}\n\n// displays the pin states\nvoid printPinStates()\n{\n\n    String pinState =  Pin 7 is  ;\n    pinState+=getPinState(7);\n    pinState+= \\r\\n ;\n\n    pinState +=  Pin 11 is  ;\n    pinState+=getPinState(11);\n    pinState+= \\r\\n ;\n\n    pinState +=  Pin 12 is  ;\n    pinState+=getPinState(12);\n    pinState+= \\r\\n ;\n\n    pinState +=  Pin 13 is  ;\n    pinState+=getPinState(13);\n    pinState+= \\r\\n ;\n\n    wiflyUart.print(pinState);\n}\n\n// prints the option to enter a pin number\nvoid printSubMenu2()\n{\n    wiflyUart.print( \\r\\nEnter the pin number you wish to toggle:  );\n}\n?\n// get a pin state as a string.\nString getPinState(int pinNumber)\n{\n    if(digitalRead(pinNumber)) // check if the pin is ON or OFF\n    {\n        return  ON ; // the pin is on\n    }\n    else\n    {\n        return  OFF ;  // the pin is off\n    }\n}  Step 3: Obtain the Shield s IP Address and Port  Open the Arduino serial monitor window to obtain the WiFiShield s IP address and port number, highlighted in the image below.   Arduino serial monitor window output from TCP example, the ip address and port number are highlighted.  In the image above the IP Address and Port would be the following:  192.168.0.10:80  Step 4: Configure The TCP Terminal and Connect to The Shield  Open RealTerm and in the  Display  tab enter  30  for  Rows  and select the  Scrollback  option:   RealTerm window: rows = 30, and Scrollback option checked.  In the  Port  tab of the RealTerm program, type your shield s IP address and port e.g. 192.168.0.10:80, then click the  Open  button, the Arduino s hard coded main menu should display in the terminal.   RealTerm window. Port field has WiFi shield s IP address and port number. The Arduino s menu is displayed  In the  Send  tab select one of the options from the menu either  1  or  2 , enter it in the text box and press  Send ASCII  to send the value.  For example, to toggle pin 13 enter  2  and press  Send ASCII , then when prompted  Enter the pin number you wish you toggle  enter  13  and click  Send ASCII . The Arduino should reply  Pin Toggled!  and go back to the main menu, now enter  1  and press  Send ASCII  to see the present state of the pins.   RealTerm window. The state of pin 13 was changed from OFF to ON as shown in the yellow text.", 
            "title": "Example 5 [MID]: TCP Communication With Terminal"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#advanced-example", 
            "text": "", 
            "title": "Advanced example"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#project-1-mid-use-webandroid-app-to-control-the-led", 
            "text": "Step One: Arduino Code  Upload the following code to your Arduino board replacing  myssid  and  mypassword  with your accesspoint s values respectively:      #include  SoftwareSerial.h \n    #include  WiFly.h \n\n    #define SSID       myssid \n    #define KEY        mypassword \n// check your access point's security mode, mine was WPA20-PSK\n// if yours is different you'll need to change the AUTH constant, see the file WiFly.h for avalable security codes\n    #define AUTH      WIFLY_AUTH_WPA2_PSK\n\nint flag = 0;\n\n// Pins' connection\n// Arduino       WiFly\n//  2     ----     TX\n//  3     ----     RX\n\nSoftwareSerial wiflyUart(2, 3); // create a WiFi shield serial object\nWiFly wifly( wiflyUart); // pass the wifi siheld serial object to the WiFly class\n\nvoid setup()\n{\n    wiflyUart.begin(9600); // start wifi shield uart port\n    Serial.begin(9600); // start the arduino serial port\n    Serial.println( --------- WIFLY Webserver -------- );\n\n    // wait for initilization of wifly\n    delay(1000);\n\n    wifly.reset(); // reset the shield\n    delay(1000);\n    //set WiFly params\n\n    wifly.sendCommand( set ip local 80\\r ); // set the local comm port to 80\n    delay(100);\n\n    wifly.sendCommand( set comm remote 0\\r ); // do not send a default string when a connection opens\n    delay(100);\n\n    wifly.sendCommand( set comm open *OPEN*\\r ); // set the string that the wifi shield will output when a connection is opened\n    delay(100);\n\n    Serial.println( Join   SSID );\n    if (wifly.join(SSID, KEY, AUTH)) {\n        Serial.println( OK );\n    } else {\n        Serial.println( Failed );\n    }\n\n    wifly.sendCommand( get ip\\r );\n    char c;\n\n    while (wifly.receive((uint8_t *) c, 1, 300)   0) { // print the response from the get ip command\n        Serial.print((char)c);\n    }\n\n    Serial.println( Web server ready );\n\n}\n\nvoid loop()\n{\n\n    if(wifly.available())\n    { // the wifi shield has data available\n        if(wiflyUart.find( *OPEN* )) // see if the data available is from an open connection by looking for the *OPEN* string\n        {\n            Serial.println( New Browser Request! );\n            delay(1000); // delay enough time for the browser to complete sending its HTTP request string\n            // send HTTP header\n            wiflyUart.println( HTTP/1.1 200 OK );\n            wiflyUart.println( Content-Type: text/html; charset=UTF-8 );\n            wiflyUart.println( Content-Length: 244 ); // length of HTML code\n            wiflyUart.println( Connection: close );\n            wiflyUart.println();\n\n            // send webpage's HTML code\n            wiflyUart.print( html );\n            wiflyUart.print( head );\n            wiflyUart.print( title My WiFI Shield Webpage /title );\n            wiflyUart.print( /head );\n            wiflyUart.print( body );\n            wiflyUart.print( h1 Hello World! /h1 );\n            wiflyUart.print( h3 This website is served from my WiFi module /h3 );\n            wiflyUart.print( a href=\\ http://yahoo.com\\ Yahoo! /a   a href=\\ http://google.com\\ Google /a );\n            wiflyUart.print( br/ button My Button /button );\n            wiflyUart.print( /body );\n            wiflyUart.print( /html );\n        }\n    }\n}  Step Two: Get the Shield s IP Address  Open the serial monitor window and wait for the  Web server ready  message to display. The serial monitor will also display the WiFi shield s IP address:   Arduino program serial comm output. The IP address of the shield is highlighted.  Step Three: Visiting the webpage  Now visit that IP address in your web browser. The webpage below should be displayed, it contains a link to Yahoo! and Google and a button that doesn t do anything (yet):   A simple webpage with two links and one button served from the WiFi shield.  When the webpage is visited the serial monitor window will also display a  New Browser Request!  string as shown below:   The Arduino serial comm window showing that it detected a new browser connection/request.   Note \nIn case of some browsers, like Google Chrome, even typing the URL in the bar sends a webpage request, this is because these browsers try to get the webpage's title for the user's convenience even before he/she visits the webpage.   Project 2 [HARD]: Get the weather data from the external web server\nThe RN-171 module in the WiFi shield has the ability to act as an HTML client (a text based web browser essentially), this means that we can use the shield to send and receive data from a web server. In this example you will learn to use the shield with a web Application Programming Interface (API) that displays any city s weather data (i.e. temperature, humidity, etc).   The name of the API we ll use is  OpenWeatherMap , when you send the name of a city and country to this website it returns a JSON string with weather information.  If you want to display the weather for London UK for example, please refer to the toturial in this link http://openweathermap.org/appid .Starting from 9 Oct 2015, the website requires users to sign up for a API key before visiting the API. Once you have got the API key, you will be able to visit the following URL http://api.openweathermap.org/data/2.5/weather?q=London,uk which would return a JSON string like the following, where the weather data and other information is embedded.  {\n     coord :{ lon :-0.13, lat :51.51},\n     sys :{ type :3, id :60992, message :0.0079, country : GB , sunrise :1421395087, sunset :1421425352},\n     weather :[{ id :802, main : Clouds , description : scattered clouds , icon : 03n }],\n     base : cmc stations ,\n     main :{\n         temp :277.25, humidity :79, pressure :998.4,\n         temp_min :277.25, temp_max :277.25\n    },\n     wind :{\n     speed :2, gust :5, deg :180},\n     rain :{ 3h :0}, clouds :{ all :32},\n     dt :1421372140, id :2643743, name : London , cod :200\n}  Step 1: The URL  Let us go ahead and retrieve the weather JSON string for San Francisco, US. The URL our WiFi shield needs to visit is the following (you may test it in your web browser):  http://api.openweathermap.org/data/2.5/weather?q=San%20Francisco,US  Step 2: The Arduino Code  Section 13 of the  WiFly manual  teaches you different ways to connect to a web server, but in all cases we need to specify the name of the server (or IP address if the server does not have a domain name), and then the data we wish to send.  The commands we need to send to the WiFi shield to receive the JSON string from the OpenWeatherMap server are the following:  set ip proto 18 //enable html client\nset dns name api.openweathermap.org //name of your webserver\nset ip address 0 // so WiFly will use DNS\nset ip remote 80 // standard webserver port\nset com remote 0 // turn off the REMOTE string so it does not interfere with the post \nopen // to open the connection\nGET /data/2.5/weather?q=San%20Francisco,US \\n\\n // to send the data  This is the arduino code that will send the commands:      #include  SoftwareSerial.h \n    #include  WiFly.h \n\n    #define SSID       mySSID \n    #define KEY        myPassword \n// check your access point's security mode, mine was WPA20-PSK\n// if yours is different you'll need to change the AUTH constant, see the file WiFly.h for avalable security codes\n    #define AUTH      WIFLY_AUTH_WPA2_PSK\n\n// Pins' connection\n// Arduino       WiFly\n//  2     ----     TX\n//  3     ----     RX\n\nSoftwareSerial wiflyUart(2, 3); // create a WiFi shield serial object\nWiFly wifly( wiflyUart); // pass the wifi siheld serial object to the WiFly class\n\nvoid setup()\n{\n    wiflyUart.begin(9600); // start wifi shield uart port\n    Serial.begin(9600); // start the arduino serial port\n    Serial.println( --------- OpenWeatherMap API -------- );\n\n    // wait for initilization of wifly\n    delay(3000);\n    wifly.reset(); // reset the shield\n    Serial.println( Join   SSID );\n    if (wifly.join(SSID, KEY, AUTH)) {\n        Serial.println( OK );\n    } else {\n        Serial.println( Failed );\n    }\n\n    wifly.sendCommand( set ip proto 18\\r ); //enable html client\n    delay(100);\n\n    wifly.sendCommand( set dns name api.openweathermap.org\\r ); // name of the webserver we want to connect to\n    delay(100);\n\n    wifly.sendCommand( set ip address 0\\r ); // so WiFly will use DNS\n    delay(100);\n\n    wifly.sendCommand( set ip remote 80\\r ); /// standard webserver port\n    delay(100);\n\n    wifly.sendCommand( set com remote 0\\r ); // turn off the REMOTE string so it does not interfere with the post\n    delay(100);\n\n    wifly.sendCommand( open\\r ); // open connection\n    delay(100);\n\n    wiflyUart.print( GET /data/2.5/weather?q=San%20Francisco,US \\n\\n );\n    delay(1000);\n\n}\n\nvoid loop()\n{\n    //As soon as the data  received from the Internet ,output the data through the UART Port .\n    while (wifly.available())\n    {\n        Serial.write(wifly.read());\n    }\n}  Step 3: Result  Open the serial monitor window, you should be able to see the same JSON string you saw in the browser.   JSON weather string shown in the Arduino serial monitor window.", 
            "title": "Project 1 [MID]: Use Web/Android APP to control the LED"
        }, 
        {
            "location": "/Wifi_Shield_V2.0.1/#resources", 
            "text": "WiFi Shield V2.0 Eagle Files  Schematic PDF  RN-171 Datasheet  Wifi Shield Library  WiFi Module User Manual    This is where you ll find all the commands for the RN-171 module in the shield.  What is a Seeeduino  w3schools  Great website to learn HTML, Javascript, and JQuery", 
            "title": "Resources"
        }, 
        {
            "location": "/acc/", 
            "text": "The Seeed Grove-3-Axis Digital Accelerometer(\u00b1400g) uses MEMS motion sensor H3LIS331DL. The H3LIS331DL is a low-power, high-performance, 3-axis linear digital accelerometer, with digital I2C serial interface standard output. The device features ultra low power operational modes that allow advanced power saving and smart sleep-to-wakeup functions. \n\n\nThe H3LIS331DL has dynamically user selectable full scales of \u00b1100g/\u00b1200 g/\u00b1400 g and it is capable of measuring accelerations with output data rates from 0.5 Hz to 1 kHz. It is perfect for measurements such as tilt-sensing, as well as for shock detection, impact recognition and logging, and concussion detection.  \n\n\nHOW IT WORKS\n\uf0c1\n\n\nMEMS - Micro Electro-Mechanical Systems\nA proprietary process is used to create a surface micromachined accelerometer. The technology allows processing suspended silicon structures, which are attached to the substrate in a few points called anchors and are free to move in the direction of the sensed acceleration. To be compatible with traditional packaging techniques, a cap is placed on top of the sensing element to avoid blocking the moving parts during the molding phase of the plastic encapsulation.\n\n\nWhen an acceleration is applied to the sensor, the proof mass displaces from its nominal position, causing an imbalance in the capacitive half bridge. This imbalance is measured using charge integration in response to a voltage pulse applied to the capacitor. At steady-state the nominal value of the capacitors are a few pF and when an acceleration is applied, the maximum variation of the capacitive load is in the fF range. \n\n\n\n\nFEATURES\n\uf0c1\n\n\n\n\nWide power range DC3.3V to 5V\n\n\nGrove outline\n\n\n3 axis sensing\n\n\nSmall, low-profile package: 3\u00d73\u00d71mm TFLGA\n\n\nLow power 300\u00b5A at 3.3V (typical)\n\n\n\u00b1100g /\u00b1200 g /\u00b1400 g dynamically selectable full scale\n\n\nI2C digital output interface\n\n\n10000 g high shock survivability\n\n\nECOPACK\u00aeRoHS and \u201cGreen\u201d compliant\n\n\n\n\n\n\nTip\n\n\nMore details about Grove modules please refer to \nGrove System\n\n\n\n\nPLATFORMS SUPPORTED\n\uf0c1\n\n\nGETTING STARTED\n\uf0c1\n\n\n\n\nNote\n\n\nThis chapter is based on Win10 and Arduino IDE 1.6.9\n\n\n\n\nThis is an easy-to-use module, what you need to do is connect the module to I2C port of a Base Shield. There\nre 4 pins, defined as below.\n\n\n\n\n\n\n\n\npin\n\n\nFunction\n\n\nNote\n\n\nCable color\n\n\n\n\n\n\n\n\n\n\npin1\n\n\nSCL\n\n\nI2C Clock\n\n\nYELLOW\n\n\n\n\n\n\npin2\n\n\nSDA\n\n\nI2C Data\n\n\nWHITE\n\n\n\n\n\n\npin3\n\n\nVCC\n\n\nPower, 5V/3.3V\n\n\nRED\n\n\n\n\n\n\npin4\n\n\nGND\n\n\nGround\n\n\nBLACK\n\n\n\n\n\n\n\n\nHere we will show you how this Grove-3-Axis Digital Accelerometer(\u00b1400g) works via a simple demo. First of all, you need to prepare the below stuffs:\n\n\n\n\n\n\n\n\nSeeeduino V4\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b1400g)\n\n\nBase Shield\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\n\n\n\n\n\n\nCONNECTION\n\uf0c1\n\n\nThanks to the benefit of Grove series modules, you don\nt need to solder or bread board, what you need to do is to connect the modules to the right port of Base Shield. For this demo, we have only one Grove module.\n\n\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b1400g)\n is an \nI2C\n module, Only 4 connections are required for I2C communication, include SDA, SCL, VCC and GND. We connect it to \nI2C\n port at this demo.\n\n\n\n\n\n\nDOWNLOAD THE LIBRARY\n\uf0c1\n\n\nWe provide an Arduino Library for this Grove - 3-Axis Digital Accelerometer(\u00b1400g), click on the below button to download it.\n\n\n\n\nUnzip the file and put to libraries folder of your Arduino IDE.\nThere\nre 2 examples in this library, which is consist of\n\n\n\n\nSeeed_H3LIS331DL_AdjVal\n\n\nSeeed_H3LIS331DL_Demo\n\n\n\n\nUPLOAD SKETCH TO ARDUINO\n\uf0c1\n\n\nCalibration\n\uf0c1\n\n\nThe H3LIS331DL chips are calibrated at the factory to a level of precision sufficient for most purposes. For critical applications where a higher degree of accuracy is required, you may wish to re-calibrate the sensor yourself.\n\n\nCalibration Method\n\uf0c1\n\n\nTo calibrate the sensor to the gravitational reference, you need to determine the sensor output for each axis when it is precisely aligned with the axis of gravitational pull. We prefer to use precision positioning jigs.\n\n\n\nLoad the Calibration Sketch\n\uf0c1\n\n\nLoad and run the Calibration sketch below. Click \nFile-\nExamples-\nSeeed_H3LIS331DL_Master\nSeeed_H3LIS331DL_AdjVal\n to load the example sketch from the library. Open the Serial Monitor and wait for the prompt. Follow the prompt to calibrate Z+, Z-, Y+, Y-, X+, X- in sequence. We leave 5 seconds for every step to rotate to different direction.\n\n\n\n\n\nWhen the sketch is open, select the right board and right COM Port, then click on Upload button which will take few seconds.\n\n\n\n\nCalibration Results\n\uf0c1\n\n\nOnce all six sides have been calibrated, the values will be printed in the Serial Monitor.\n\n\n\nDemo\n\uf0c1\n\n\nClick \nFile-\nExamples-\nSeeed_H3LIS331DL_Master-\nSeeed_H3LIS331DL_Demo\n to load the example sketch from the library. Then modify the VAL_X_AXIS/VAL_Y_AXIS/VAL_Z_AXIS according to what you get from H3LIS331DL_AdjVal Sketch.\n\n\n\nUpload the sketch and open the serial monitor and open the serial monitor to check the result.\n\n\n\nAPIS OF THE LIBRARY\n\uf0c1\n\n\ninit()\n\uf0c1\n\n\nThe init() function initializes communication with the device.\n\n\nExample:\n\n\nh3lis.init();   //Initialization\n\n\n\nimportPara(x,y,z)\n\uf0c1\n\n\nThe importPara() function import the calibration offset values from Seeed_H3LIS331DL_AdjVal sketch.\nExample:\n\n\nh3lis.importPara(VAL_X_AXIS,VAL_Y_AXIS,VAL_Z_AXIS);   //Import calibration offset data\n\n\n\nreadXYZ(\nx,\ny,\nz)\n\uf0c1\n\n\nThe readXYZ() function returns X, Y and Z axis readings from the accelerometer.\nExample:\n\n\nh3lis.readXYZ(\nx,\ny,\nz);  //Read XYZ axis\n\n\n\ngetAcceleration(xyz)\n\uf0c1\n\n\nThe getAcceleration() function return X, Y and Z axis acceleration reading from the accelerometer.\nExample:\n\n\nh3lis.getAcceleration(xyz);  //Read XYZ axis acceleration data\n\n\n\ngetAdjParameter()\n\uf0c1\n\n\nThe getAcceleration() function return X, Y and Z axis calibration offset reading from the accelerometer.\nExample:\n\n\ngetAdjParameter();   //Read XYZ axis calibration offset data.\n\n\n\nRESOURCES\n\uf0c1\n\n\n\n\nGrove-3-Axis Digital Accelerometer(\u00b1400g) Library\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b1400g) Eagle File\n\n\nH3LIS331DL Datasheet PDF", 
            "title": "Grove-3-Axis Digital Accelerometer(\u00b1400g)"
        }, 
        {
            "location": "/acc/#how-it-works", 
            "text": "MEMS - Micro Electro-Mechanical Systems\nA proprietary process is used to create a surface micromachined accelerometer. The technology allows processing suspended silicon structures, which are attached to the substrate in a few points called anchors and are free to move in the direction of the sensed acceleration. To be compatible with traditional packaging techniques, a cap is placed on top of the sensing element to avoid blocking the moving parts during the molding phase of the plastic encapsulation.  When an acceleration is applied to the sensor, the proof mass displaces from its nominal position, causing an imbalance in the capacitive half bridge. This imbalance is measured using charge integration in response to a voltage pulse applied to the capacitor. At steady-state the nominal value of the capacitors are a few pF and when an acceleration is applied, the maximum variation of the capacitive load is in the fF range.", 
            "title": "HOW IT WORKS"
        }, 
        {
            "location": "/acc/#features", 
            "text": "Wide power range DC3.3V to 5V  Grove outline  3 axis sensing  Small, low-profile package: 3\u00d73\u00d71mm TFLGA  Low power 300\u00b5A at 3.3V (typical)  \u00b1100g /\u00b1200 g /\u00b1400 g dynamically selectable full scale  I2C digital output interface  10000 g high shock survivability  ECOPACK\u00aeRoHS and \u201cGreen\u201d compliant    Tip  More details about Grove modules please refer to  Grove System", 
            "title": "FEATURES"
        }, 
        {
            "location": "/acc/#platforms-supported", 
            "text": "", 
            "title": "PLATFORMS SUPPORTED"
        }, 
        {
            "location": "/acc/#getting-started", 
            "text": "Note  This chapter is based on Win10 and Arduino IDE 1.6.9   This is an easy-to-use module, what you need to do is connect the module to I2C port of a Base Shield. There re 4 pins, defined as below.     pin  Function  Note  Cable color      pin1  SCL  I2C Clock  YELLOW    pin2  SDA  I2C Data  WHITE    pin3  VCC  Power, 5V/3.3V  RED    pin4  GND  Ground  BLACK     Here we will show you how this Grove-3-Axis Digital Accelerometer(\u00b1400g) works via a simple demo. First of all, you need to prepare the below stuffs:     Seeeduino V4  Grove - 3-Axis Digital Accelerometer(\u00b1400g)  Base Shield           Get ONE Now  Get ONE Now  Get ONE Now", 
            "title": "GETTING STARTED"
        }, 
        {
            "location": "/acc/#connection", 
            "text": "Thanks to the benefit of Grove series modules, you don t need to solder or bread board, what you need to do is to connect the modules to the right port of Base Shield. For this demo, we have only one Grove module.   Grove - 3-Axis Digital Accelerometer(\u00b1400g)  is an  I2C  module, Only 4 connections are required for I2C communication, include SDA, SCL, VCC and GND. We connect it to  I2C  port at this demo.", 
            "title": "CONNECTION"
        }, 
        {
            "location": "/acc/#download-the-library", 
            "text": "We provide an Arduino Library for this Grove - 3-Axis Digital Accelerometer(\u00b1400g), click on the below button to download it.   Unzip the file and put to libraries folder of your Arduino IDE.\nThere re 2 examples in this library, which is consist of   Seeed_H3LIS331DL_AdjVal  Seeed_H3LIS331DL_Demo", 
            "title": "DOWNLOAD THE LIBRARY"
        }, 
        {
            "location": "/acc/#upload-sketch-to-arduino", 
            "text": "", 
            "title": "UPLOAD SKETCH TO ARDUINO"
        }, 
        {
            "location": "/acc/#calibration", 
            "text": "The H3LIS331DL chips are calibrated at the factory to a level of precision sufficient for most purposes. For critical applications where a higher degree of accuracy is required, you may wish to re-calibrate the sensor yourself.", 
            "title": "Calibration"
        }, 
        {
            "location": "/acc/#calibration-method", 
            "text": "To calibrate the sensor to the gravitational reference, you need to determine the sensor output for each axis when it is precisely aligned with the axis of gravitational pull. We prefer to use precision positioning jigs.", 
            "title": "Calibration Method"
        }, 
        {
            "location": "/acc/#load-the-calibration-sketch", 
            "text": "Load and run the Calibration sketch below. Click  File- Examples- Seeed_H3LIS331DL_Master Seeed_H3LIS331DL_AdjVal  to load the example sketch from the library. Open the Serial Monitor and wait for the prompt. Follow the prompt to calibrate Z+, Z-, Y+, Y-, X+, X- in sequence. We leave 5 seconds for every step to rotate to different direction.   When the sketch is open, select the right board and right COM Port, then click on Upload button which will take few seconds.", 
            "title": "Load the Calibration Sketch"
        }, 
        {
            "location": "/acc/#calibration-results", 
            "text": "Once all six sides have been calibrated, the values will be printed in the Serial Monitor.", 
            "title": "Calibration Results"
        }, 
        {
            "location": "/acc/#demo", 
            "text": "Click  File- Examples- Seeed_H3LIS331DL_Master- Seeed_H3LIS331DL_Demo  to load the example sketch from the library. Then modify the VAL_X_AXIS/VAL_Y_AXIS/VAL_Z_AXIS according to what you get from H3LIS331DL_AdjVal Sketch.  Upload the sketch and open the serial monitor and open the serial monitor to check the result.", 
            "title": "Demo"
        }, 
        {
            "location": "/acc/#apis-of-the-library", 
            "text": "", 
            "title": "APIS OF THE LIBRARY"
        }, 
        {
            "location": "/acc/#init", 
            "text": "The init() function initializes communication with the device.  Example:  h3lis.init();   //Initialization", 
            "title": "init()"
        }, 
        {
            "location": "/acc/#importparaxyz", 
            "text": "The importPara() function import the calibration offset values from Seeed_H3LIS331DL_AdjVal sketch.\nExample:  h3lis.importPara(VAL_X_AXIS,VAL_Y_AXIS,VAL_Z_AXIS);   //Import calibration offset data", 
            "title": "importPara(x,y,z)"
        }, 
        {
            "location": "/acc/#readxyzxyz", 
            "text": "The readXYZ() function returns X, Y and Z axis readings from the accelerometer.\nExample:  h3lis.readXYZ( x, y, z);  //Read XYZ axis", 
            "title": "readXYZ(&amp;x,&amp;y,&amp;z)"
        }, 
        {
            "location": "/acc/#getaccelerationxyz", 
            "text": "The getAcceleration() function return X, Y and Z axis acceleration reading from the accelerometer.\nExample:  h3lis.getAcceleration(xyz);  //Read XYZ axis acceleration data", 
            "title": "getAcceleration(xyz)"
        }, 
        {
            "location": "/acc/#getadjparameter", 
            "text": "The getAcceleration() function return X, Y and Z axis calibration offset reading from the accelerometer.\nExample:  getAdjParameter();   //Read XYZ axis calibration offset data.", 
            "title": "getAdjParameter()"
        }, 
        {
            "location": "/acc/#resources", 
            "text": "Grove-3-Axis Digital Accelerometer(\u00b1400g) Library  Grove - 3-Axis Digital Accelerometer(\u00b1400g) Eagle File  H3LIS331DL Datasheet PDF", 
            "title": "RESOURCES"
        }
    ]
}